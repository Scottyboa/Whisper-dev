<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title id="page-title-transcribe">Transcription Tool with Ads and Guide Overlay</title>
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500&family=Merriweather:wght@300;400&display=swap" rel="stylesheet">
  <!-- Include external translations file -->
  <script src="translations.js"></script>
  <style>
    body {
      font-family: 'Roboto', sans-serif;
      background-color: #f8f8f8;
      color: #333;
      margin: 0;
      padding: 0;
    }
    /* Style for the OpenAI usage hyperlink */
    #openaiUsageLink {
      position: fixed;
      top: 30px;       
      right: 400px;    
      font-size: 18px; 
      text-decoration: underline;
      color: #0077cc;
      z-index: 1000;
    }
    /* Grid Layout */
    .grid-container {
      display: grid;
      grid-template-columns: 250px 1fr 250px;
      height: 100vh;
    }
    /* Left Sidebar */
    .sidebar {
      background-color: #e0e0e0;
      padding: 20px;
      display: flex;
      flex-direction: column;
      gap: 20px;
      position: relative;
    }
    .sidebar button {
      font-size: 18px;
      padding: 15px;
    }
    /* Main Content Area */
    .main-content {
      padding: 20px;
      display: flex;
      flex-direction: column;
      gap: 20px;
      overflow-y: auto;
    }
    /* Recording Area (Top Half) */
    .recording-area {
      border-bottom: 1px solid #ddd;
      padding-bottom: 20px;
    }
    .timer {
      font-size: 18px;
      margin-bottom: 10px;
      color: #333;
    }
    /* Auto-resizing Textareas */
    #transcription, #generatedNote, #customPrompt {
      width: 100%;
      padding: 12px;
      border: 1px solid #ddd;
      border-radius: 10px;
      font-size: 16px;
      box-sizing: border-box;
      margin-bottom: 20px;
      font-family: 'Roboto', sans-serif;
      resize: none;
    }
    /* Allow vertical resize for the transcription output field */
    #transcription {
      resize: vertical;
    }
    #transcription, #generatedNote {
      min-height: 150px;
    }
    #customPrompt {
      min-height: 200px;
    }
    button {
      background-color: #5a9;
      color: #fff;
      border: none;
      border-radius: 10px;
      padding: 12px 20px;
      font-size: 16px;
      cursor: pointer;
      transition: background-color 0.3s, transform 0.1s;
      margin: 10px;
    }
    button:hover {
      background-color: #489;
    }
    button:active {
      transform: scale(0.98);
    }
    /* Bottom Half: Two Columns */
    .bottom-half {
      display: flex;
      gap: 20px;
      flex: 1;
    }
    .column {
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    /* Right Sidebar (Ad Area) */
    .ad-sidebar {
      background-color: #e0e0e0;
      padding: 20px;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    #adUnit {
      width: 100%;
      height: 200px;
      background-color: #ddd;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 18px;
      margin-bottom: 10px;
    }
    /* Guide Overlay */
    #guideView {
      display: none;
      position: fixed;
      top: 10%;
      left: 10%;
      width: 80%;
      height: 80%;
      background: white;
      border: 2px solid #ccc;
      padding: 20px;
      overflow-y: auto;
      z-index: 2000;
    }
    #guideView.active {
      display: block;
    }
    /* Language Dropdown in Sidebar */
    #lang-container-transcribe {
      position: absolute;
      bottom: 20px;
      left: 20px;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    #lang-icon-transcribe {
      width: 28px;
      height: 28px;
    }
    /* Consent Banner */
    #cmp-banner {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      background: #f8f8f8;
      border-top: 1px solid #ccc;
      padding: 20px;
      text-align: center;
      font-size: 16px;
      z-index: 1000;
      box-shadow: 0 -2px 5px rgba(0,0,0,0.1);
    }
    #cmp-banner button {
      margin-left: 10px;
      padding: 8px 16px;
    }
  </style>
</head>
<body>
  <!-- OpenAI usage hyperlink -->
  <a id="openaiUsageLink" href="https://platform.openai.com/usage" target="_blank">Cost usage overview</a>
  
  <div class="grid-container">
    <!-- Left Sidebar -->
    <aside class="sidebar">
      <button id="btnFunctions">Functions</button>
      <button id="btnGuide">Guide</button>
      <!-- Language dropdown at bottom of sidebar -->
      <div id="lang-container-transcribe">
        <img src="language-icon.png" alt="Language Icon" id="lang-icon-transcribe">
        <select id="lang-select-transcribe">
          <option value="en">English</option>
          <option value="no">Norsk</option>
          <option value="sv">Svenska</option>
          <option value="zh">中文</option>
          <option value="de">Deutsch</option>
          <option value="fr">Français</option>
        </select>
      </div>
    </aside>
    <!-- Main Content -->
    <main class="main-content">
      <!-- Top Half: Recording Area -->
      <div class="recording-area">
        <h3 id="recordingAreaTitle">Recording Area</h3>
        <div id="recordIndicator" style="width:20px; height:20px; border-radius:50%; background-color:grey; margin:0 auto 10px;"></div>
        <div id="recordTimer" class="timer">Recording Timer: 0 sec</div>
        <div id="uploadTimer" class="timer">Upload Timer: 0 sec</div>
        <div id="transcribeTimer" class="timer">Transcription Timer: 0 sec</div>
        <textarea id="transcription" placeholder="Transcription result will appear here..."></textarea>
        <div>
          <button id="startButton">Start Recording</button>
          <button id="stopButton" disabled>Stop Recording</button>
          <button id="pauseResumeButton" disabled>Pause Recording</button>
          <button id="transcribeButton" disabled>Transcribe</button>
        </div>
        <div id="statusMessage">Welcome! Click "Start Recording" to begin.</div>
      </div>
      <!-- Bottom Half: Note Generation and Custom Prompt -->
      <div class="bottom-half">
        <div class="column">
          <h3 id="noteGenerationTitle">Note Generation</h3>
          <button id="generateNoteButton">Generate Note</button>
          <div id="noteTimer" class="timer">Note Generation Timer: 0 sec</div>
          <textarea id="generatedNote" readonly placeholder="Generated note will appear here..."></textarea>
        </div>
        <div class="column">
          <h3 id="customPromptTitle">Custom Prompt</h3>
          <label for="promptSlot" id="promptSlotLabel">Prompt Slot:</label>
          <select id="promptSlot">
            <option value="1">1</option>
            <option value="2">2</option>
            <option value="3">3</option>
            <option value="4">4</option>
            <option value="5">5</option>
            <option value="6">6</option>
            <option value="7">7</option>
            <option value="8">8</option>
            <option value="9">9</option>
            <option value="10">10</option>
          </select>
          <textarea id="customPrompt" placeholder="Enter custom prompt here" rows="1"></textarea>
        </div>
      </div>
    </main>
    <!-- Right Sidebar (Ad Area) -->
    <aside class="ad-sidebar">
      <div id="adArea">
        <div id="adUnit">Your Ad Here</div>
      </div>
    </aside>
  </div>
  <!-- Consent Banner -->
  <div id="cmp-banner">
    <span id="consent-text">This website is free to use because we rely solely on ad revenue. We use cookies to personalize ads and improve your experience. By clicking "Accept", you consent to the use of cookies.</span>
    <button id="cmp-accept">Accept</button>
    <button id="cmp-manage">Manage</button>
  </div>
  <script>
    document.addEventListener("DOMContentLoaded", function() {
      /* --------------------------
         Multi-language & Consent Banner Logic
         -------------------------- */
      // Use the external translations from translations.js
      const transcribeTranslations = window.translations.transcribeTranslations;
      
      function updateLanguageTranscribe(lang) {
        document.getElementById("page-title-transcribe").textContent = transcribeTranslations[lang].pageTitle;
        document.getElementById("openaiUsageLink").textContent = transcribeTranslations[lang].openaiUsageLinkText;
        document.getElementById("btnFunctions").textContent = transcribeTranslations[lang].btnFunctions;
        document.getElementById("btnGuide").textContent = transcribeTranslations[lang].btnGuide;
        document.getElementById("recordingAreaTitle").textContent = transcribeTranslations[lang].recordingAreaTitle;
        document.getElementById("recordTimer").textContent = transcribeTranslations[lang].recordTimer;
        document.getElementById("uploadTimer").textContent = transcribeTranslations[lang].uploadTimer;
        document.getElementById("transcribeTimer").textContent = transcribeTranslations[lang].transcribeTimer;
        document.getElementById("transcription").setAttribute("placeholder", transcribeTranslations[lang].transcriptionPlaceholder);
        document.getElementById("startButton").textContent = transcribeTranslations[lang].startButton;
        document.getElementById("stopButton").textContent = transcribeTranslations[lang].stopButton;
        document.getElementById("pauseResumeButton").textContent = transcribeTranslations[lang].pauseButton;
        document.getElementById("transcribeButton").textContent = transcribeTranslations[lang].transcribeButton;
        document.getElementById("statusMessage").textContent = transcribeTranslations[lang].statusMessage;
        document.getElementById("noteGenerationTitle").textContent = transcribeTranslations[lang].noteGenerationTitle;
        document.getElementById("generateNoteButton").textContent = transcribeTranslations[lang].generateNoteButton;
        document.getElementById("noteTimer").textContent = transcribeTranslations[lang].noteTimer;
        document.getElementById("generatedNote").setAttribute("placeholder", transcribeTranslations[lang].generatedNotePlaceholder);
        document.getElementById("customPromptTitle").textContent = transcribeTranslations[lang].customPromptTitle;
        document.getElementById("promptSlotLabel").textContent = transcribeTranslations[lang].promptSlotLabel;
        document.getElementById("customPrompt").setAttribute("placeholder", transcribeTranslations[lang].customPromptPlaceholder);
        document.getElementById("adUnit").textContent = transcribeTranslations[lang].adUnitText;
        document.getElementById("guideHeading").textContent = transcribeTranslations[lang].guideHeading;
        document.getElementById("guideText").innerHTML = transcribeTranslations[lang].guideText;
        // Update consent text so it changes with language selection.
        document.getElementById("consent-text").textContent = transcribeTranslations[lang].consentText;
      }
      
      let currentLangTranscribe = localStorage.getItem("siteLanguage") || "en";
      document.getElementById("lang-select-transcribe").value = currentLangTranscribe;
      updateLanguageTranscribe(currentLangTranscribe);
      document.getElementById("lang-select-transcribe").addEventListener("change", function() {
        currentLangTranscribe = this.value;
        localStorage.setItem("siteLanguage", currentLangTranscribe);
        updateLanguageTranscribe(currentLangTranscribe);
      });
      
      /* --------------------------
         Consent Banner & Cookie Management for Transcribe Page
         -------------------------- */
      function setCookieTranscribe(name, value, days) {
        var expires = "";
        if (days) {
          var date = new Date();
          date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000));
          expires = "; expires=" + date.toUTCString();
        }
        document.cookie = name + "=" + (value || "") + expires + "; path=/";
      }
      function getCookieTranscribe(name) {
        var nameEQ = name + "=";
        var ca = document.cookie.split(';');
        for (var i = 0; i < ca.length; i++) {
          var c = ca[i];
          while (c.charAt(0) === ' ') c = c.substring(1);
          if (c.indexOf(nameEQ) === 0) return c.substring(nameEQ.length);
        }
        return null;
      }
      function loadAdSenseTranscribe() {
        var script = document.createElement('script');
        script.async = true;
        script.src = "https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js";
        document.head.appendChild(script);
        (adsbygoogle = window.adsbygoogle || []).push({});
      }
      document.getElementById("cmp-accept").addEventListener("click", function() {
        setCookieTranscribe("user_consent", "accepted", 365);
        document.getElementById("cmp-banner").style.display = "none";
        loadAdSenseTranscribe();
      });
      document.getElementById("cmp-manage").addEventListener("click", function() {
        alert("Here you can manage your cookie and ad preferences.");
      });
      (function() {
        if (getCookieTranscribe("user_consent") === "accepted") {
          document.getElementById("cmp-banner").style.display = "none";
          loadAdSenseTranscribe();
        }
      })();
      
      /* --------------------------
         Chunked Recording Logic & Transcription Functionality
         -------------------------- */
      
      // Define the backend URL
      const backendUrl = "https://whisper-dev-backend.fly.dev";
      
      // Global variables for chunked recording
      let mediaRecorder;
      let mediaStream = null;
      let audioChunks = [];
      let recordingStartTime = 0;
      let recordingTimerInterval;
      let uploadTimerInterval;
      let groupId = null;
      let chunkNumber = 0;
      let autoChunkTimer = null;
      let manualStop = false;  // true if user manually stops the overall recording
      
      function updateStatusMessage(message, color = "#333") {
        const statusMessage = document.getElementById("statusMessage");
        statusMessage.innerText = message;
        statusMessage.style.color = color;
      }
      
      function formatTime(ms) {
        const totalSec = Math.floor(ms / 1000);
        if (totalSec < 60) {
          return totalSec + " sec";
        } else {
          const minutes = Math.floor(totalSec / 60);
          const seconds = totalSec % 60;
          return minutes + " min" + (seconds > 0 ? " " + seconds + " sec" : "");
        }
      }
      
      function updateRecordingTimer() {
        let elapsed = Date.now() - recordingStartTime;
        document.getElementById("recordTimer").innerText = "Recording Timer: " + formatTime(elapsed);
      }
      
      function updateUploadTimer() {
        let elapsed = Date.now() - uploadStartTime;
        document.getElementById("uploadTimer").innerText = "Upload Timer: " + formatTime(elapsed);
      }
      
      function stopMicrophone() {
        if (mediaStream) {
          mediaStream.getTracks().forEach(track => track.stop());
          mediaStream = null;
        }
      }
      
      function startNewChunk() {
        audioChunks = [];
        recordingStartTime = Date.now();
        clearInterval(recordingTimerInterval);
        updateRecordingTimer();
        recordingTimerInterval = setInterval(updateRecordingTimer, 1000);
        
        mediaRecorder = new MediaRecorder(mediaStream);
        mediaRecorder.ondataavailable = event => {
          if (event.data.size > 0) {
            audioChunks.push(event.data);
          }
        };
        mediaRecorder.onstop = handleStop;
        mediaRecorder.start();
        
        autoChunkTimer = setTimeout(() => {
          console.log("Auto chunk stop reached for chunk " + chunkNumber);
          mediaRecorder.stop();
        }, 600000);
        
        updateStatusMessage(`Recording chunk ${chunkNumber} in progress...`, "red");
        document.getElementById("recordIndicator").style.backgroundColor = "red";
      }
      
      async function handleStop() {
        clearInterval(recordingTimerInterval);
        updateStatusMessage(`Uploading chunk ${chunkNumber}... Please wait.`, "blue");
      
        const audioBlob = new Blob(audioChunks, { type: 'audio/mp3' });
        const formData = new FormData();
        formData.append("file", audioBlob, `chunk_${chunkNumber}.mp3`);
        formData.append("group_id", groupId);
        formData.append("chunk_number", chunkNumber);
      
        uploadStartTime = Date.now();
        document.getElementById("uploadTimer").innerText = "Upload Timer: 0 sec";
        uploadTimerInterval = setInterval(updateUploadTimer, 1000);
      
        try {
          const response = await fetch(`${backendUrl}/upload`, {
            method: "POST",
            body: formData
          });
          const result = await response.json();
          clearInterval(uploadTimerInterval);
      
          if (result.session_id) {
            console.log(`Chunk ${chunkNumber} uploaded. Session ID: `, result.session_id);
            if (manualStop) {
              updateStatusMessage("Upload complete! You may now start transcribing.", "green");
              document.getElementById("transcribeButton").disabled = false;
              stopMicrophone();
            } else {
              chunkNumber++;
              startNewChunk();
            }
          } else {
            updateStatusMessage("Upload error: " + (result.error || "Unknown error"), "red");
          }
        } catch (error) {
          updateStatusMessage("Error uploading file: " + error, "red");
        }
      }
      
      document.getElementById("startButton").addEventListener("click", async () => {
        manualStop = false;
        try {
          mediaStream = await navigator.mediaDevices.getUserMedia({ audio: true });
          groupId = Date.now().toString();
          chunkNumber = 1;
          startNewChunk();
      
          document.getElementById("startButton").disabled = true;
          document.getElementById("stopButton").disabled = false;
          document.getElementById("pauseResumeButton").disabled = false;
          document.getElementById("pauseResumeButton").innerText = "Pause Recording";
        } catch (error) {
          updateStatusMessage("Microphone access error: " + error, "red");
        }
      });
      
      document.getElementById("stopButton").addEventListener("click", () => {
        manualStop = true;
        clearTimeout(autoChunkTimer);
        if (mediaRecorder && mediaRecorder.state !== "inactive") {
          mediaRecorder.stop();
          document.getElementById("startButton").disabled = false;
          document.getElementById("stopButton").disabled = true;
          document.getElementById("pauseResumeButton").disabled = true;
        }
      });
      
      document.getElementById("pauseResumeButton").addEventListener("click", () => {
        if (!mediaRecorder) return;
        if (mediaRecorder.state === "recording") {
          mediaRecorder.pause();
          clearInterval(recordingTimerInterval);
          document.getElementById("pauseResumeButton").innerText = "Resume Recording";
          updateStatusMessage("Recording paused", "orange");
        } else if (mediaRecorder.state === "paused") {
          mediaRecorder.resume();
          recordingStartTime = Date.now();
          recordingTimerInterval = setInterval(updateRecordingTimer, 1000);
          document.getElementById("pauseResumeButton").innerText = "Pause Recording";
          updateStatusMessage("Recording resumed", "green");
        }
      });
      
      document.getElementById("transcribeButton").addEventListener("click", async () => {
        const storedApiKey = sessionStorage.getItem("openai_api_key");
        if (!storedApiKey) {
          updateStatusMessage("API key missing.", "red");
          return;
        }
      
        updateStatusMessage("Transcription in progress...", "blue");
        const transcriptionStart = Date.now();
        transcriptionTimerInterval = setInterval(() => {
          document.getElementById("transcribeTimer").innerText = "Transcription Timer: " + Math.floor((Date.now() - transcriptionStart) / 1000) + " s";
        }, 1000);
      
        try {
          const response = await fetch(`${backendUrl}/transcribe`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ api_key: storedApiKey, session_id: groupId })
          });
          const result = await response.json();
          clearInterval(transcriptionTimerInterval);
      
          if (result.transcription) {
            updateStatusMessage("Transcription complete!", "green");
            document.getElementById("transcription").value = result.transcription;
          } else {
            updateStatusMessage("No transcription available.", "red");
          }
        } catch (error) {
          updateStatusMessage("Transcription error: " + error, "red");
        }
      });
      
      /* --------------------------
         Custom Prompt and Note Generation Functionality
         -------------------------- */
      
      const promptSlotSelect = document.getElementById("promptSlot");
      const customPromptTextarea = document.getElementById("customPrompt");
      
      function hashString(str) {
        let hash = 0;
        for (let i = 0; i < str.length; i++) {
          const char = str.charCodeAt(i);
          hash = ((hash << 5) - hash) + char;
          hash |= 0;
        }
        return hash.toString();
      }
      
      function getPromptStorageKey(slot) {
        const apiKey = sessionStorage.getItem("openai_api_key") || "";
        const hashedApiKey = hashString(apiKey);
        return "customPrompt_" + hashedApiKey + "_" + slot;
      }
      
      function autoResize(textarea) {
        textarea.style.height = "auto";
        textarea.style.height = textarea.scrollHeight + "px";
      }
      
      function loadPromptForSlot(slot) {
        const key = getPromptStorageKey(slot);
        const storedPrompt = localStorage.getItem(key);
        customPromptTextarea.value = storedPrompt ? storedPrompt : "";
        autoResize(customPromptTextarea);
      }
      
      customPromptTextarea.addEventListener("input", () => {
        const currentSlot = promptSlotSelect.value;
        const key = getPromptStorageKey(currentSlot);
        localStorage.setItem(key, customPromptTextarea.value);
        autoResize(customPromptTextarea);
      });
      
      promptSlotSelect.addEventListener("change", () => {
        loadPromptForSlot(promptSlotSelect.value);
      });
      
      loadPromptForSlot(promptSlotSelect.value);
      
      document.getElementById("generateNoteButton").addEventListener("click", async () => {
        const transcriptionText = document.getElementById("transcription").value.trim();
        if (!transcriptionText) {
          alert("No transcription text available.");
          return;
        }
        
        const promptText = customPromptTextarea.value;
        const generatedNoteField = document.getElementById("generatedNote");
        generatedNoteField.value = "";
        
        const noteStartTime = Date.now();
        const noteTimerElement = document.getElementById("noteTimer");
        noteTimerElement.innerText = "Note Generation Timer: 0 sec";
        const noteTimerInterval = setInterval(() => {
          noteTimerElement.innerText = "Note Generation Timer: " + formatTime(Date.now() - noteStartTime);
        }, 1000);
        
        const apiKey = sessionStorage.getItem("openai_api_key");
        try {
          const response = await fetch("https://api.openai.com/v1/chat/completions", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              "Authorization": "Bearer " + apiKey
            },
            body: JSON.stringify({
              model: "gpt-4-turbo",
              messages: [
                { role: "system", content: promptText },
                { role: "user", content: transcriptionText }
              ],
              temperature: 0.7,
              stream: true
            })
          });
          
          const reader = response.body.getReader();
          const decoder = new TextDecoder("utf-8");
          let done = false;
          
          while (!done) {
            const { value, done: doneReading } = await reader.read();
            done = doneReading;
            const chunkValue = decoder.decode(value);
            const lines = chunkValue.split("\n").filter(line => line.trim() !== "");
            for (const line of lines) {
              if (line.startsWith("data: ")) {
                const jsonStr = line.replace("data: ", "").trim();
                if (jsonStr === "[DONE]") {
                  done = true;
                  break;
                }
                try {
                  const parsed = JSON.parse(jsonStr);
                  const textChunk = parsed.choices[0].delta?.content || "";
                  generatedNoteField.value += textChunk;
                  autoResize(generatedNoteField);
                } catch (err) {
                  console.error("Stream chunk parsing error:", err);
                }
              }
            }
          }
          clearInterval(noteTimerInterval);
          noteTimerElement.innerText = "Text generation completed!";
        } catch (error) {
          clearInterval(noteTimerInterval);
          generatedNoteField.value = "Error generating note: " + error;
          noteTimerElement.innerText = "";
        }
      });
      
      /* ---------------- End of Custom Prompt & Note Generation ---------------- */
    });
  </script>
</body>
</html>
