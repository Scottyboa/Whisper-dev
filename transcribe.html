

<!DOCTYPE html>
<html lang="en">
<head>
  <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web@1.14.0/dist/ort.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@ricky0123/vad-web@0.0.22/dist/bundle.min.js"></script>
<!-- Removed hard-coded recording.js include; provider will choose module -->
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
 <!-- 1) Load Google’s Funding Choices library -->
 <script async src="https://fundingchoicesmessages.google.com/i/pub-3747901131960450?ers=1"></script>

 <!-- 2) Immediately signal that Funding Choices is running -->
 <script>
    (function() {
      function signalGooglefcPresent() {
        if (!window.frames['googlefcPresent']) {
          if (document.body) {
            const iframe = document.createElement('iframe');
            iframe.style = 'width: 0; height: 0; border: none; z-index: -1000; left: -1000px; top: -1000px;';
            iframe.style.display = 'none';
            iframe.name = 'googlefcPresent';
            document.body.appendChild(iframe);
          } else {
            setTimeout(signalGooglefcPresent, 0);
          }
        }
      }
      signalGooglefcPresent();
    })();
  </script>  <title id="page-title-transcribe">Transcribe Notes – AI Medical Transcription & Clinical Notes for Doctors</title>
  <!-- Meta description for crawlers -->
  <meta name="description"
        content="Secure, AI-powered medical transcription and clinical note generation for healthcare professionals. Ideal for documenting hypertension, diabetes, COPD, and medication regimens." />

  <!-- Meta keywords (for legacy bidders) -->
  <meta name="keywords"
        content="medical transcription, clinical notes, AI for doctors, pharmaceutical, medications, hypertension, diabetes, COPD, healthcare professional, semaglutide, Ozempic, Vimovo, apixaban, Eliquis, lisdexamfetamine, Aduvanz, omalizumab, Xolair, fremanezumab, Ajovy, rivaroxaban, Xarelto, alirocumab, Praluent, methylphenidate, Ritalin, dapagliflozin, Forxiga, atorvastatin, Lipitor, mirabegron, Betmiga, methotrexate, Metex, valsartan, sakubitril, Entresto, empagliflozin, Jardiance, tree pollen, Itulazax, mesalazine, Asacol, grass pollen, Grazax, erenumab, Aimovig, metoprolol, Selo-Zok, formoterol, glykopyrroniumbromid"/>
  <meta property="og:type" content="website">
  <meta property="og:title" content="Transcribe Notes – AI Medical Transcription & Clinical Notes for Doctors">
  <meta property="og:description" content="Secure, AI-powered medical transcription and clinical note generation for healthcare professionals.">
  <meta property="og:image" content="https://transcribe-notes.netlify.app/Preview.png">
  <meta property="og:url" content="https://transcribe-notes.netlify.app/transcribe.html">

  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="Transcribe Notes – AI Medical Transcription & Clinical Notes for Doctors">
  <meta name="twitter:description" content="Secure, AI-powered medical transcription and clinical note generation for healthcare professionals.">
  <meta name="twitter:image" content="https://transcribe-notes.netlify.app/Preview.png">


<script async src="https://securepubads.g.doubleclick.net/tag/js/gpt.js"></script>
<script>
  window.googletag = window.googletag || { cmd: [] };
  googletag.cmd.push(function() {
    // define slots and save them globally
    window.slotTopLeft     = googletag.defineSlot('/23295908256/Big-top-left',  [300,600], 'div-gpt-ad-1744469658576-0').addService(googletag.pubads());
    window.slotTopRight    = googletag.defineSlot('/23295908256/big-top-right',[300,600], 'div-gpt-ad-1744469682244-0').addService(googletag.pubads());
    window.slotBottomLeft  = googletag.defineSlot('/23295908256/bottom-left',  [300,250], 'div-gpt-ad-1744473133809-0').addService(googletag.pubads());
    window.slotBottomRight = googletag.defineSlot('/23295908256/bottom-right',[300,250], 'div-gpt-ad-1744473114007-0').addService(googletag.pubads());

    // declare inventory as refreshable…
    googletag.pubads().setTargeting('refreshable','true');
    // …and fetch all slots in a single request
    googletag.pubads().enableSingleRequest();
    googletag.pubads().setForceSafeFrame(true);

    // only call enableServices() once
    googletag.enableServices();
  });
</script>
  <link
    href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500&family=Merriweather:wght@300;400&display=swap"
    rel="stylesheet"
  />
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet" />
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@graph": [
    {
      "@type": "Organization",
      "@id": "https://transcribe-notes.netlify.app/#organization",
      "name": "Transcribe Notes",
      "url": "https://transcribe-notes.netlify.app/"
    },
    {
      "@type": "WebSite",
      "@id": "https://transcribe-notes.netlify.app/#website",
      "url": "https://transcribe-notes.netlify.app/",
      "name": "Transcribe Notes",
      "publisher": {
        "@id": "https://transcribe-notes.netlify.app/#organization"
      }
    },
    {
      "@type": "MedicalWebPage",
      "@id": "https://transcribe-notes.netlify.app/transcribe.html#medicalwebpage",
      "url": "https://transcribe-notes.netlify.app/transcribe.html",
      "name": "Transcribe Notes – Medical Transcription for Clinicians",
      "description": "An AI-powered medical transcription and clinical note tool for doctors, covering conditions like hypertension, diabetes, COPD, and medication management."
    },
    {
      "@type": "SoftwareApplication",
      "@id": "https://transcribe-notes.netlify.app/#software",
      "name": "Transcribe Notes",
      "applicationCategory": "MedicalApplication",
      "operatingSystem": "All",
      "description": "Secure AI-powered medical transcription and note generation for healthcare professionals. Supports documentation of medications such as Atorvastatin, Metformin, Seretide.",
      "url": "https://transcribe-notes.netlify.app/",
      "author": {
        "@id": "https://transcribe-notes.netlify.app/#organization"
      },
      "offers": {
        "@type": "Offer",
        "price": "0.00",
        "priceCurrency": "USD"
      },
      "audience": {
        "@type": "Audience",
        "audienceType": "Healthcare Professional"
      },
      "keywords": "medical transcription, clinical notes, pharmaceutical, medications, hypertension, diabetes, COPD, healthcare professional, semaglutide, Ozempic, apixaban, Eliquis, lisdexamfetamine, Aduvanz, omalizumab, Xolair, fremanezumab, Ajovy, rivaroxaban, Xarelto, alirocumab, Praluent, methylphenidate, Ritalin, dapagliflozin, Forxiga, atorvastatin, Lipitor, mirabegron, Betmiga, methotrexate, Metex, valsartan, sakubitril, Entresto, empagliflozin, Jardiance, tree pollen, Itulazax, mesalazine, Asacol, grass pollen, Grazax, erenumab, Aimovig, metoprolol, Selo-Zok, formoterol, glykopyrroniumbromid"
    }
  ]
}
</script>
  <style>
    /* Base Styles */
    html,
    body {
      margin: 0;
      padding: 0;
    }
    body {
      font-family: 'Inter', 'Roboto', sans-serif;
      font-weight: 400;
      background-color: #f8f8f8;
      color: #333;
    }

    /* Make all form UI use the same font as the page text */
    input, select, textarea, button {
      font-family: inherit;
      font-weight: 400;
    }

    /* Avoid “random bold” label rendering */
    label {
      font-family: inherit;
      font-weight: 400;
    }
    /* Grid Layout: Single Row, 3 Columns */
    .grid-container {
      display: grid;
      grid-template-columns: 300px 1fr 300px; /* Left sidebar, main content, right sidebar */
      grid-template-rows: auto; /* Allow rows to size based on content */
      min-height: 1200px;       /* Ensure the grid is always at least 1200px tall */
    }
   /* When ad columns are disabled, main content uses full width */
    .grid-container.ads-disabled {
      grid-template-columns: 1fr;
    }
    .grid-container.ads-disabled .sidebar,
    .grid-container.ads-disabled .ad-sidebar {
      display: none;
    }
    /* When ads are off, let main content span the single column */
    .grid-container.ads-disabled .main-content {
      grid-column: 1 / 2;
    }
    /* Left Sidebar - Updated: No padding and no gap so ads fill the space */
    .sidebar {
      grid-column: 1 / 2;
      grid-row: 1 / 2;
      background-color: #e0e0e0;
      padding: 0;
      display: flex;
      flex-direction: column;
      gap: 0;
      position: relative;
    }
    /* Right Sidebar (Ad Area) */
    .ad-sidebar {
      grid-column: 3 / 4;
      grid-row: 1 / 2;
      background-color: #e0e0e0;
      /* Remove top padding so the ad is pushed up */
      padding: 0 20px 20px;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    /* Main Content */
    .main-content {
      grid-column: 2 / 3;
      grid-row: 1 / 2;
      display: flex;
      flex-direction: column;
      overflow-y: auto;
      /* Remove horizontal padding so top bar is flush with sidebars */
      padding: 0;
    }
    /* Top Bar within main content */
    .top-bar {
      background-color: #e0e0e0; /* Matches sidebars */
      padding: 20px;            /* Increased padding for a thicker bar */
      margin-bottom: 20px;      /* Space below the top bar */
      display: flex;
      align-items: center;
      justify-content: space-between;
    }
    .top-bar button {
      font-size: 18px;
      padding: 10px 20px;
    }
    /* Language Container in Top Bar (right side) */
    #lang-container-transcribe {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    #lang-icon-transcribe {
      width: 36px;
      height: 36px;
    }
    #lang-select-transcribe {
      padding: 5px;
      font-size: 18px;
    }

    /* Medical calculator picker (top bar, compact) */
    #medical-calc-container {
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
    }
    #medicalCalcLabel {
      font-size: 16px;
      margin: 0;
      white-space: nowrap;
    }
    #medicalCalcSelect {
      padding: 5px;
      font-size: 16px;
      max-width: 220px;
    }
    #medicalCalcOpenBtn {
      margin: 0;           /* override global button margin */
      padding: 6px 10px;   /* smaller than other buttons */
      font-size: 14px;
      border-radius: 8px;
    }
    /* Recording Area */
    .recording-area {
      border-bottom: 1px solid #ddd;
      padding-bottom: 20px;
      padding-left: 20px;
      padding-right: 20px;
    }
    .recording-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
    }

    /* Provider row (between Recording Area header and timer) */
    .transcribe-provider-row {
      display: flex;
      align-items: center;
      gap: 12px;
      flex-wrap: wrap;
      margin: 6px 0 10px;
    }
    .transcribe-provider-row label { white-space: nowrap; }
    #provider-container,
    #soniox-region-container {
      display: flex;
      align-items: center;
      gap: 8px;
      margin: 0;
    }
    #soniox-region-note {
      margin: 0;
      font-size: 12px;
      color: #666;
      line-height: 1.2;
    }
    .timer {
      font-size: 18px;
      margin-bottom: 10px;
      color: #333;
      display: flex;
      align-items: baseline;
      gap: 8px;
    }
    .timer-status:empty { display: none; }
    .timer-status {
      font-weight: normal;
      opacity: 0.85;
    }
    /* Secondary completion label shown *below* the timer (only on completion) */
    .timer-status-below {
      margin-top: 6px;
      font-size: 18px;         /* match .timer font-size */
      font-weight: normal;
      opacity: 0.85;
      color: #2e7d32;
    }
    .timer-status-below:empty { display: none; }

    /* Note token/cost readout (separate element so #noteTimer innerText can't wipe it) */
    .note-usage-cost {
      margin-top: 4px;
      font-size: 12px;
      opacity: 0.6;
      color: #333;
      white-space: nowrap;
    }
    .note-usage-cost:empty { display: none; }
    /* Cost Overview Hyperlink */
    #openaiUsageLink {
      font-size: 16px;
      font-family: inherit;
      text-decoration: underline;
      color: blue;
      margin: 0;
    }
    #openaiUsageLink:hover {
      color: darkblue;
    }
    /* Auto-resizing Textareas */
    #transcription,
    #generatedNote,
    #customPrompt,
    #supplementaryInfo {
      width: 100%;
      padding: 12px;
      border: 1px solid #ddd;
      border-radius: 10px;
      font-size: 16px;
      box-sizing: border-box;
      margin-bottom: 20px;
      font-family: 'Roboto', sans-serif;
      resize: none;
    }
    #transcription {
      resize: vertical;
    }
#transcription {
  min-height: 150px;
  resize: vertical;
  overflow-y: auto;
  overflow-x: hidden;
}
#supplementaryInfo {
  min-height: 90px;
  resize: vertical;
  overflow-y: auto;
  overflow-x: hidden;
}

#generatedNote {
  min-height: 750px; 
  resize: vertical;
  overflow-y: auto;
  overflow-x: hidden;
}
    #customPrompt {
      min-height: 200px;
      resize: vertical; /* user can resize manually */
    }
    /* Button Styles */
    button {
      background-color: #5a9;
      color: #fff;
      border: none;
      border-radius: 10px;
      padding: 12px 20px;
      font-size: 16px;
      cursor: pointer;
      transition: background-color 0.3s, transform 0.1s;
      margin: 10px;
    }
    button:hover {
      background-color: #489;
    }
    button:active {
      transform: scale(0.98);
    }
    button:disabled {
      background-color: #ccc;
      color: #666;
      cursor: not-allowed;
      opacity: 0.6;
      transition: none;
      transform: none;
    }
    /* Bottom Half: Two Columns */
    .bottom-half {
      display: flex;
      gap: 20px;
      flex: 1;
      padding: 0 20px; /* Maintain side padding for bottom half content */
    }
    .column {
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    /* Prompt profile row (Custom Prompt column) */
    .prompt-profile-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      flex-wrap: wrap;
      margin-top: -6px;
    }
    .prompt-profile-left {
      font-size: 14px;
      color: #555;
    }
    .prompt-profile-actions {
      display: flex;
      gap: 8px;
      align-items: center;
    }
    .prompt-profile-actions button {
      font-size: 14px;
      padding: 6px 10px;
    }
    /* Ad Containers for Right Sidebar */
    #right-ad-unit-1 {
      width: 300px;
      min-height: 250px;
      background: transparent;
      margin-bottom: 0;
    }
    #right-ad-unit-2 {
      width: 300px;
      min-height: 250px;
      background: transparent;
      margin-top: 10px;
    }
    /* Ad Containers for Left Sidebar */
    #left-ad-unit-1 {
      width: 100%;
      min-height: 150px;
      background: transparent;
      margin-bottom: 10px;
    }
    #left-ad-unit-2 {
      width: 100%;
      min-height: 150px;
      background: transparent;
    }
    /* Hide leftover forced-color-adjust elements */
    div[style*="forced-color-adjust: initial"] {
      display: none !important;
      height: 0 !important;
      margin: 0 !important;
      padding: 0 !important;
    }
    /* Guide Overlay Styles */
    #guideView {
      display: none;
      position: fixed;
      top: 10%;
      left: 10%;
      width: 80%;
      height: 80%;
      background: white;
      border: 2px solid #ccc;
      padding: 20px;
      overflow-y: auto;
      z-index: 2000;
    }
    #guideView.active {
      display: block;
    }
    #guideClose {
      position: sticky;
      top: 10px;
      float: right;
      background: none;
      border: none;
      color: red;
      font-size: 26px;
      line-height: 1;
      cursor: pointer;
      margin: 0;     /* override global button margin */
      padding: 0 6px;/* override global button padding */
      z-index: 2001;
    }

    /* Costs & Billing Links Overlay Styles */
    #billingLinksView {
      display: none;
      position: fixed;
      top: 10%;
      left: 10%;
      width: 80%;
      height: 80%;
      background: white;
      border: 2px solid #ccc;
      padding: 20px;
      overflow-y: auto;
      z-index: 2001;
    }
    #billingLinksView.active {
      display: block;
    }
    #billingLinksView .header-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      margin-bottom: 12px;
    }
    #billingLinksClose {
      font-size: 22px;
      line-height: 1;
      padding: 6px 10px;
      border-radius: 8px;
      cursor: pointer;
    }
    #billingLinksTable {
      width: 100%;
      border-collapse: collapse;
    }
    #billingLinksTable th,
    #billingLinksTable td {
      border: 1px solid #ddd;
      padding: 10px;
      vertical-align: top;
    }
    #billingLinksTable th {
      position: sticky;
      top: 0;
      background: #f7f7f7;
      z-index: 1;
    }
  </style>
</head>
<body>
  <div class="grid-container">
    <!-- Left Sidebar (reserved for ads) with two new ad units -->
    <aside class="sidebar">
<!-- /23295908256/Big-top-left -->
<div id='div-gpt-ad-1744469658576-0' style='min-width: 300px; min-height: 600px;'>
  <script>
    googletag.cmd.push(function() { googletag.display('div-gpt-ad-1744469658576-0'); });
  </script>
</div>
<!-- /23295908256/bottom-left -->
<div id='div-gpt-ad-1744473133809-0' style='min-width: 300px; min-height: 250px;'>
  <script>
    googletag.cmd.push(function() { googletag.display('div-gpt-ad-1744473133809-0'); });
  </script>
</div>
    </aside>
    <!-- Main Content (center column) -->
    <main class="main-content">
      <!-- Top Bar inside Main Content -->
<!-- Top Bar inside Main Content -->
<div class="top-bar">
  <!-- Back to frontpage button stays on the far left -->
  <button id="backToHomeButton" type="button">Back to frontpage</button>
<script>
  document.getElementById('backToHomeButton').addEventListener('click', () => {
    const loc = window.location;
    const newPath = loc.pathname.replace(/\/[^\/]*$/, '/index.html'); // keep /Whisper-dev/
    window.location.href = loc.origin + newPath + loc.search + loc.hash;
  });
</script>





  <!-- Group for "Read first! ➔" and Guide button -->
  <div class="mid-controls" style="display: flex; align-items: center;">
  <span id="read-first-text" style="font-size: 28px; color: black; margin-right: 10px;">Read first! ➔</span>
    <button id="btnGuide">Guide</button>
  </div>
  <!-- Medical calculator picker (opens selected HTML in a new tab) -->
  <div id="medical-calc-container">
    <label id="medicalCalcLabel" for="medicalCalcSelect">Kliniske verktøy:</label>
    <select id="medicalCalcSelect" aria-label="Medical calculator">
      <option value="" selected>Select…</option>
      <option value="./kliniske_verktøy/BMI_kalkulator.html">BMI / KMI</option>
      <option value="./kliniske_verktøy/growth_charts_no_upload.html">Vektskurver WHO barn 0-19 år</option>
      <option value="./kliniske_verktøy/omeq.html">OMEQ (morfinekvivalenter)</option>
      <option value="./kliniske_verktøy/terminkalkulator.html">Terminkalkulator</option>
      <option value="./kliniske_verktøy/norrisk2.html">NORRISK 2</option>
      <option value="./kliniske_verktøy/chadvasc.html">CHA₂DS₂-VASc</option>
      <option value="./kliniske_verktøy/Fri_testosteron_index.html">Fri androgen-indeks / fritt testosteron</option>
    </select>
    <button id="medicalCalcOpenBtn" type="button" disabled>Open</button>
  </div>


  <!-- Language container remains on the far right -->
  <div id="lang-container-transcribe">
    <img src="language-icon.png" alt="Language Icon" id="lang-icon-transcribe" />
    <select id="lang-select-transcribe">
      <option value="en">English</option>
      <option value="no">Norsk</option>
      <option value="sv">Svenska</option>
      <option value="de">Deutsch</option>
      <option value="fr">Français</option>
      <option value="it">Italiano</option>
    </select>
  </div>

  
</div>
      <!-- Recording Area -->
      <div class="recording-area">
<div class="recording-header">
  <h3 id="recordingAreaTitle">Recording Area</h3>
  <a id="openaiUsageLink" href="#" role="button" aria-controls="billingLinksView">
    Cost usage overview
  </a>
 </div>
        <!-- Provider row moved here (between header and timer) -->
        <div class="transcribe-provider-row">
          <!-- Transcription Provider selector -->
          <div id="provider-container">
            <label for="transcribeProvider" id="providerLabel">Provider:</label>
            <select id="transcribeProvider">
              <option value="openai">OpenAI</option>
              <option value="soniox">Soniox</option>              
              <option value="lemonfox">Lemonfox</option>
              <option value="voxtral">Mistral(Voxtral Small)</option>
              <option value="deepgram">Deepgram Nova-3</option>
            </select>
          </div>
          <!-- Soniox Speaker Labels selector (shown only for Soniox) -->
          <div id="soniox-speaker-labels-container" style="display:none;">
            <!-- "Spk" is short + fairly universal in audio UIs; tooltip provides clarity without i18n -->
            <label for="sonioxSpeakerLabels" id="sonioxSpeakerLabelsLabel" title="Speaker labels">Speaker labels:</label>
            <select id="sonioxSpeakerLabels" aria-label="Speaker labels">
              <option value="off" selected>Off</option>
              <option value="on">On</option>
            </select>
          </div>


          <!-- Soniox Region selector (shown only for Soniox providers) -->
          <div id="soniox-region-container" style="display:none;">
            <label for="sonioxRegion" id="sonioxRegionLabel">Region:</label>
            <select id="sonioxRegion">
              <option value="us">US</option>
              <option value="eu">EU (GDPR Compliant)</option>
            </select>
          </div>

          <!-- EU note (shown only when Region = EU) -->
          <div id="soniox-region-note" style="display:none;">
            (EU endpoint requires
            <a href="https://soniox.com/docs/stt/data-residency"
               target="_blank" rel="noopener noreferrer">EU API key</a> from SONIOX)
          </div>
        </div>

        <div id="recordTimer" class="timer">Recording Timer: 0 sec</div>
        <!-- Completion timer + Clear button on same row -->
        <div style="display:flex; align-items: baseline; justify-content: space-between; gap: 12px; margin-bottom: 10px;">
          <div id="transcribeTimer" class="timer" style="margin-bottom: 0;">Completion Timer: 0 sec</div>
          <button
            id="clearTranscriptionButton"
            type="button"
            style="
              padding: 4px 10px;
              font-size: 12px;
              border-radius: 6px;
              background-color: #5a9;
            "
          >
            Clear
          </button>
        </div>
        <textarea
          id="transcription"
          placeholder="Transcription result will appear here."
          style="margin-bottom: 6px;"  
        ></textarea>

        <!-- Clear button row ABOVE supplementary field -->
        <div style="display: flex; justify-content: flex-end; margin-bottom: 5px;">
          <button
            id="clearSupplementaryButton"
            type="button"
            style="
              padding: 4px 10px;
              font-size: 12px;
              border-radius: 6px;
              background-color: #5a9;
            "
          >
            Clear
          </button>
        </div>

        <!-- Supplementary field (NO label above) -->
        <textarea
          id="supplementaryInfo"
          placeholder="Supplementary information (optional)"></textarea>
        <div>
   <button id="startButton">Start</button>
    <button id="stopButton" disabled>Stop</button>
  <button id="pauseResumeButton" disabled>Pause Recording</button>
        </div>
        <div id="statusMessage">Welcome! Click "Start Recording" to begin.</div>
      </div>
      <!-- Note Generation & Custom Prompt -->
      <div class="bottom-half">
      <div class="column">
          <h3 id="noteGenerationTitle">Note Generation</h3>
          <!-- Phase 3: Note Provider selector (module switch only; both use OpenAI key) -->
          <div id="note-provider-container" style="display:flex; align-items:center; gap:8px; margin: 6px 0 6px;">
            <label for="noteProvider" id="noteProviderLabel">Provider:</label>
            <select id="noteProvider">
              <option value="openai">OpenAI</option>
              <option value="lemonfox">Lemonfox</option>
              <option value="mistral">Mistral</option>
              <option value="gemini3">Gemini 3(Google AI studio)</option> <!-- Gemini via public API -->
              <option value="gemini3-vertex">Google Vertex</option> <!-- Vertex-backed models (e.g. Gemini 2.5 Pro) -->
              <option value="aws-bedrock" selected>AWS Bedrock</option>
            </select>
            <!-- OpenAI model selector (shown only when Provider = OpenAI) -->
            <div id="openai-model-container"
                 style="display:none; align-items:center; gap:6px; margin-left:8px;">
              <label for="openaiModel" id="openaiModelLabel">Model:</label>
              <select id="openaiModel">
                <option value="gpt5" selected>GPT-5.1</option>
                <option value="gpt52">GPT-5.2</option>
                <option value="gpt4">GPT-4-latest</option>
              </select>
            </div>
            <div id="note-provider-mode-container" style="display:none; align-items:center; gap:8px;">
              <label for="noteProviderMode" id="noteProviderModeLabel">Mode:</label>
              <select id="noteProviderMode">
                <option value="streaming" selected>streaming</option>
                <option value="non-streaming">non-streaming</option>
              </select>
            </div>

            <!-- New: Vertex model selector (shown only when Note Provider = Google Vertex) -->
            <div id="vertex-model-container"
                 style="display:none; align-items:center; gap:6px; margin-left:8px;">
              <label for="vertexModel" id="vertexModelLabel">Model:</label>
              <select id="vertexModel">
                <option value="gemini-2.5-pro" selected>Gemini 2.5 Pro</option>
              </select>
            </div>

            <!-- AWS Bedrock model selector (shown only when Note Provider = AWS Bedrock) -->
            <div id="bedrock-model-container"
                 style="display:none; align-items:center; gap:6px; margin-left:8px;">
              <label for="bedrockModel" id="bedrockModelLabel">Model:</label>
              <select id="bedrockModel">
               <option value="haiku-4-5">Claude Haiku 4.5</option>
               <option value="sonnet-4-5">Claude Sonnet 4.5</option>
               <option value="opus-4-5" selected>Claude Opus 4.5</option>
                
               
              </select>
            </div>
          </div>

          <!-- GPT-5.1 reasoning level selector (only shown for GPT-5.1 providers) -->
          <div id="gpt5-reasoning-container"
               style="display:none; align-items:center; gap:8px; margin: 0 0 10px;">
            <label for="gpt5Reasoning" id="gpt5ReasoningLabel">Reasoning level:</label>
            <select id="gpt5Reasoning">
              <option value="none">None</option>
              <option value="low" selected>Low</option>
              <option value="medium">Medium</option>
              <option value="high">High</option>
              <option value="xhigh" id="gpt5ReasoningXHigh" hidden disabled>Extra High (xhigh)</option>
            </select>
          </div>
          <!-- Gemini 3 reasoning level selector (only shown for Gemini3 provider) -->
          <div id="gemini-reasoning-container"
               style="display:none; align-items:center; gap:8px; margin: 0 0 10px;">
            <label for="geminiReasoning" id="geminiReasoningLabel">Gemini reasoning:</label>
            <select id="geminiReasoning">
              <option value="low" selected>Low</option>
              <option value="high">High</option>
            </select>
          </div>
          <button id="generateNoteButton">Generate Note</button>
          <!-- Note timer + Copy button on the same row -->
          <div style="display:flex; align-items: baseline; justify-content: space-between; gap: 12px; margin-bottom: 6px;">
            <div id="noteTimer" class="timer" style="margin-bottom: 0;">
              <span id="noteTimerValue">Note Generation Timer: 0 sec</span>
              <span id="noteTimerStatus" class="timer-status"></span>
            </div>
            <button
              id="copyNoteButton"
              type="button"
              aria-label="Copy generated note"
              style="
                padding: 4px 10px;
                font-size: 12px;
                border-radius: 6px;
                background-color: #5a9;
                margin: 0;
              "
            >
              Copy
            </button>
          </div>
        <div id="noteTimerStatusBelow" class="timer-status-below"></div>
        <!-- Separate (non-timer) UI line for tokens/cost so it never gets overwritten by #noteTimer.innerText -->
        <div id="noteUsageCost" class="note-usage-cost"></div>
          <textarea id="generatedNote" placeholder="Generated note will appear here..."></textarea>
        </div>
        <div class="column">
          <h3 id="customPromptTitle">Custom Prompt</h3>

          <!-- New: Prompt profile status + Import/Export -->
          <div class="prompt-profile-row">
            <div class="prompt-profile-left">
              <span id="promptProfileLabel">Prompt profile:</span>
              <span id="promptProfileValue">(not set)</span>
            </div>
            <div class="prompt-profile-actions">
              <button id="promptExportBtn" type="button">Export</button>
              <button id="promptImportBtn" type="button">Import</button>
              <input id="promptImportFile" type="file" accept="application/json" style="display:none;">
            </div>
          </div>

          <label for="promptSlot" id="promptSlotLabel">Prompt Slot:</label>
          <select id="promptSlot">
            <option value="1">1</option>
            <option value="2">2</option>
            <option value="3">3</option>
            <option value="4">4</option>
            <option value="5">5</option>
            <option value="6">6</option>
            <option value="7">7</option>
            <option value="8">8</option>
            <option value="9">9</option>
            <option value="10">10</option>
          </select>
          <textarea id="customPrompt" placeholder="Enter custom prompt here" rows="1"></textarea>
        </div>
      </div>
    </main>
    <!-- Right Sidebar (Ad Area) -->
    <aside class="ad-sidebar">
<!-- /23295908256/big-top-right -->
<div id='div-gpt-ad-1744469682244-0' style='min-width: 300px; min-height: 600px;'>
  <script>
    googletag.cmd.push(function() { googletag.display('div-gpt-ad-1744469682244-0'); });
  </script>
</div>
<!-- /23295908256/bottom-right -->
<div id='div-gpt-ad-1744473114007-0' style='min-width: 300px; min-height: 250px;'>
  <script>
    googletag.cmd.push(function() { googletag.display('div-gpt-ad-1744473114007-0'); });
  </script>
</div>
    </aside>
  </div>

  <!-- New (Phase 2): Provider wiring. Sets user_api_key and reloads to re-init correct module -->
  <script>
    (function () {
      const OPENAI = "openai";
      const SONIOX = "soniox";
      const SONIOX_DIA = "soniox_dia";
      const LEMONFOX = "lemonfox";
      const VOXTRAL = "voxtral";
      const DEEPGRAM = "deepgram";
      const sel = document.getElementById("transcribeProvider");
      const regionContainer = document.getElementById("soniox-region-container");
      const regionSel = document.getElementById("sonioxRegion");
      const regionNote = document.getElementById("soniox-region-note");
      const spkContainer = document.getElementById("soniox-speaker-labels-container");
      const spkSel = document.getElementById("sonioxSpeakerLabels");
      if (!sel) return;

      function applyProvider(p) {
  sessionStorage.setItem("transcribe_provider", p);
  const openaiKey = sessionStorage.getItem("openai_api_key") || "";
  const sonioxKey = sessionStorage.getItem("soniox_api_key") || "";
  const lemonKey = sessionStorage.getItem("lemonfox_api_key") || "";
  const mistralKey = sessionStorage.getItem("mistral_api_key") || "";
  const deepgramKey = sessionStorage.getItem("deepgram_api_key") || "";

  // Pick the active key by provider; default to OpenAI for unknowns
  const chosen =
    (p === "soniox" || p === "soniox_dia") ? sonioxKey :
    (p === "lemonfox") ? lemonKey :
    (p === "voxtral") ? mistralKey :
    (p === "deepgram") ? deepgramKey :
    openaiKey;

  sessionStorage.setItem("user_api_key", chosen);
}

      // --- Soniox Region handling ---
      function isSoniox(p) { return p === SONIOX || p === SONIOX_DIA; }
      function currentRegion() {
        const r = (sessionStorage.getItem("soniox_region") || "eu").toLowerCase();
        return (r === "eu") ? "eu" : "us";
      }
      function currentSpeakerLabels() {
        const v = (sessionStorage.getItem("soniox_speaker_labels") || "off").toLowerCase();
        return (v === "on") ? "on" : "off";
      }
      function applySpeakerVisibility(p) {
        if (!spkContainer || !spkSel) return;
        if (isSoniox(p)) {
          spkContainer.style.display = "flex";
          spkSel.value = currentSpeakerLabels();
        } else {
          spkContainer.style.display = "none";
        }
      }
      function applyRegionVisibility(p) {
        if (!regionContainer || !regionSel) return;
        if (isSoniox(p)) {
          regionContainer.style.display = "flex";
          // Initialize selector from storage (default 'us')
          regionSel.value = currentRegion();
          // Note should only show for EU region
          if (regionNote) {
            const val = (regionSel.value || "us").toLowerCase();
            regionNote.style.display = (val === "eu") ? "block" : "none";
          }
        } else {
          regionContainer.style.display = "none";
          if (regionNote) regionNote.style.display = "none";
        }
      }
      // Persist region on change; next API call will read it via getSonioxBase()
      if (regionSel) {
        regionSel.addEventListener("change", () => {
          const val = (regionSel.value || "us").toLowerCase();
          sessionStorage.setItem("soniox_region", val === "eu" ? "eu" : "us");
          // Show or hide the note depending on region
          if (regionNote) {
            regionNote.style.display = (val === "eu") ? "block" : "none";
          }
        });
      }

      // Initialize from previous choice or default to Soniox.
      // Back-compat: if user previously had "soniox_dia", migrate to "soniox" + labels=on.
      let stored = sessionStorage.getItem("transcribe_provider") || SONIOX;
      if (stored === SONIOX_DIA) {
        stored = SONIOX;
        sessionStorage.setItem("transcribe_provider", SONIOX);
        sessionStorage.setItem("soniox_speaker_labels", "on");
      }
      // Default speaker labels to off if missing
      if (!sessionStorage.getItem("soniox_speaker_labels")) {
        sessionStorage.setItem("soniox_speaker_labels", "off");
      }
      // Default Soniox region to EU on first load (only if not previously set)
      if (!sessionStorage.getItem("soniox_region")) {
        sessionStorage.setItem("soniox_region", "eu");
      }
      sel.value = stored;
      applyProvider(stored);
      // Ensure Region UI is in correct state on load
      applyRegionVisibility(stored);
      applySpeakerVisibility(stored);

      // Also set correct initial visibility for the note (EU only)
      const currentVal = (regionSel?.value || "us").toLowerCase();
      if (regionNote) {
        regionNote.style.display = (isSoniox(stored) && currentVal === "eu") ? "block" : "none";
      }

      // On change: try soft-switch; if not available, persist state and reload (fallback)
      sel.addEventListener("change", async () => {
        applyProvider(sel.value);
        applyRegionVisibility(sel.value);
        applySpeakerVisibility(sel.value);

        // If a previous recording was just stopped and transcription is still finishing,
        // hard-reload to prevent stale async jobs from writing into the new provider's UI.
        const mustHardReload =
          window.__app &&
          typeof window.__app.isTranscribeBusy === "function" &&
          window.__app.isTranscribeBusy();

        if (mustHardReload) {
          if (window.__app && typeof window.__app.saveState === "function") {
            window.__app.saveState();
          }
          window.location.reload();
          return;
        }
        // Soft switch if our app helper exists
        if (window.__app && typeof window.__app.switchTranscribeProvider === "function") {
          try {
            await window.__app.switchTranscribeProvider(sel.value);
            return; // no reload needed
          } catch (e) {
            console.warn("Soft recording switch failed, falling back to reload", e);
          }
        }
        // Fallback: persist UI state then reload
        if (window.__app && typeof window.__app.saveState === "function") {
          window.__app.saveState();
        }
        window.location.reload();
      });

      // Speaker labels toggle should re-init Soniox module (regular vs diarization)
      if (spkSel) {
        spkSel.addEventListener("change", async () => {
          const v = (spkSel.value || "off").toLowerCase();
          sessionStorage.setItem("soniox_speaker_labels", v === "on" ? "on" : "off");

          // Only relevant for Soniox; if selected, re-init recording module
          if (isSoniox(sel.value)) {
            const mustHardReload =
              window.__app &&
              typeof window.__app.isTranscribeBusy === "function" &&
              window.__app.isTranscribeBusy();

            if (mustHardReload) {
              if (window.__app && typeof window.__app.saveState === "function") window.__app.saveState();
              window.location.reload();
              return;
            }

            if (window.__app && typeof window.__app.switchTranscribeProvider === "function") {
              try {
                await window.__app.switchTranscribeProvider(SONIOX);
              } catch (e) {
                console.warn("Soft recording switch failed (speaker labels), falling back to reload", e);
                if (window.__app && typeof window.__app.saveState === "function") window.__app.saveState();
                window.location.reload();
              }
            }
          }
        });
      }
    })();
  </script>
  
  <!-- Phase 3: Note provider persistence (no reload; module chosen in main.js) -->
<script>
    (function () {
      const DEFAULT_PROVIDER = "aws-bedrock";
      const DEFAULT_OPENAI_MODEL = "gpt5";
      const providerSel = document.getElementById("noteProvider");
      const openaiModelContainer = document.getElementById("openai-model-container");
      const openaiModelSel = document.getElementById("openaiModel");

      const gptReasoningContainer = document.getElementById("gpt5-reasoning-container");
      const geminiReasoningContainer = document.getElementById("gemini-reasoning-container");
      const vertexModelContainer = document.getElementById("vertex-model-container");
      const vertexModelSelect = document.getElementById("vertexModel");
      const bedrockModelContainer = document.getElementById("bedrock-model-container");
      const bedrockModelSelect = document.getElementById("bedrockModel");

      if (!providerSel) return;

      const noteModeContainer = document.getElementById("note-provider-mode-container");
      const noteModeSel = document.getElementById("noteProviderMode");

      // Canonical provider key used for module switching (main.js still switches on note_provider).
      // Examples:
      //   - OpenAI: gpt5 / gpt5-ns / gpt52 / gpt52-ns / gpt4
      //   - Others: lemonfox / mistral / gemini3 / gemini3-vertex / aws-bedrock
      const storedProviderKey = sessionStorage.getItem("note_provider");

      let initialProvider = DEFAULT_PROVIDER;
      let initialOpenAiModel = DEFAULT_OPENAI_MODEL;
      let initialMode = "streaming";

      if (storedProviderKey) {
        const isNs = storedProviderKey.endsWith("-ns");
        const baseKey = isNs ? storedProviderKey.replace(/-ns$/, "") : storedProviderKey;

        if (baseKey === "gpt5" || baseKey === "gpt52" || baseKey === "gpt4") {
          initialProvider = "openai";
          initialOpenAiModel = baseKey;

          // Mode only applies to GPT-5.x
          if ((baseKey === "gpt5" || baseKey === "gpt52") && isNs) {
            initialMode = "non-streaming";
          }
        } else {
          initialProvider = baseKey;
        }
      }

      // Fallbacks if sessionStorage contains an unknown value
      if (!Array.from(providerSel.options).some(o => o.value === initialProvider)) {
        initialProvider = DEFAULT_PROVIDER;
        initialOpenAiModel = DEFAULT_OPENAI_MODEL;
        initialMode = "streaming";
      }

      providerSel.value = initialProvider;
      if (openaiModelSel) openaiModelSel.value = initialOpenAiModel;
      if (noteModeSel) noteModeSel.value = initialMode;

      function getEffectiveNoteProvider(provider, model, mode) {
        if (provider !== "openai") return provider;
        const isGpt5x = model === "gpt5" || model === "gpt52";
        if (!isGpt5x) return model;
        return mode === "non-streaming" ? `${model}-ns` : model;
      }

      // Restore previously chosen Vertex model (if any)
      if (vertexModelSelect) {
        const storedVertexModel = sessionStorage.getItem("vertex_model");
        if (storedVertexModel) {
          vertexModelSelect.value = storedVertexModel;
        }
        vertexModelSelect.addEventListener("change", () => {
          sessionStorage.setItem("vertex_model", vertexModelSelect.value);
        });
      }

      // Bedrock model preference (if any)
      if (bedrockModelSelect) {
        const storedBedrockModel = sessionStorage.getItem("bedrock_model");
        // If user previously had "sonnet-4", migrate to "sonnet-4-5" (since Sonnet 4 is removed from UI)
        const migrated =
          storedBedrockModel === "sonnet-4" ? "sonnet-4-5" : storedBedrockModel;

        // Only apply if it exists in the dropdown; otherwise keep the HTML default.
        if (migrated && Array.from(bedrockModelSelect.options).some(o => o.value === migrated)) {
          bedrockModelSelect.value = migrated;
          if (migrated !== storedBedrockModel) {
            sessionStorage.setItem("bedrock_model", migrated);
          }
        } else if (storedBedrockModel) {
          // Stored value is unknown/outdated; reset to current UI selection.
          sessionStorage.setItem("bedrock_model", bedrockModelSelect.value);
        } else {
          // First load: persist the HTML default (Opus 4.5 after the change above)
          sessionStorage.setItem("bedrock_model", bedrockModelSelect.value);
        }
        bedrockModelSelect.addEventListener("change", () => {
          sessionStorage.setItem("bedrock_model", bedrockModelSelect.value);
        });
      }

      function updateVisibility() {
        const provider = providerSel.value;
        const model = openaiModelSel ? openaiModelSel.value : DEFAULT_OPENAI_MODEL;

        const isOpenAi = provider === "openai";
        const isGpt51 = isOpenAi && model === "gpt5";
        const isGpt52 = isOpenAi && model === "gpt52";
        const isGpt5x = isGpt51 || isGpt52;

        const isGemini3 = provider === "gemini3"; // public Gemini 3 API only
        const isVertex = provider === "gemini3-vertex"; // Google Vertex backend
        const isBedrock = provider === "aws-bedrock"; // AWS Bedrock backend

        if (openaiModelContainer) {
          openaiModelContainer.style.display = isOpenAi ? "flex" : "none";
        }
        if (openaiModelSel) {
          openaiModelSel.disabled = !isOpenAi;
        }

        // Mode only for GPT-5.x
        const showMode = isGpt5x;
        if (noteModeContainer) {
          noteModeContainer.style.display = showMode ? "flex" : "none";
        }
        if (noteModeSel) {
          noteModeSel.disabled = !showMode;
          // Keep a sane default when hidden
          if (!showMode) noteModeSel.value = "streaming";
        }

        if (gptReasoningContainer) {
          gptReasoningContainer.style.display = isGpt5x ? "flex" : "none";

          // Only GPT-5.2 providers should expose xhigh
          const xhighOpt = document.getElementById("gpt5ReasoningXHigh");
          const reasoningSel = document.getElementById("gpt5Reasoning");
          if (xhighOpt) {
            xhighOpt.hidden = !isGpt52;
            xhighOpt.disabled = !isGpt52;
          }

          // If user had xhigh selected and switches away from GPT-5.2, downgrade to high.
          if (!isGpt52 && reasoningSel && reasoningSel.value === "xhigh") {
            reasoningSel.value = "high";
          }
        }

        if (geminiReasoningContainer) {
          geminiReasoningContainer.style.display = isGemini3 ? "flex" : "none";
        }
        if (vertexModelContainer) {
          vertexModelContainer.style.display = isVertex ? "flex" : "none";
        }
        if (bedrockModelContainer) {
          bedrockModelContainer.style.display = isBedrock ? "flex" : "none";
        }
      }

      async function syncNoteProvider() {
        const effective = getEffectiveNoteProvider(
          providerSel.value,
          openaiModelSel ? openaiModelSel.value : DEFAULT_OPENAI_MODEL,
          noteModeSel ? noteModeSel.value : "streaming"
        );

        sessionStorage.setItem("note_provider", effective);
        if (noteModeSel) sessionStorage.setItem("note_mode", noteModeSel.value);

        if (window.__app && typeof window.__app.switchNoteProvider === "function") {
          await window.__app.switchNoteProvider(effective);
        }
      }

      // Initial state on page load
      updateVisibility();
      // Persist initial values
      syncNoteProvider();

      // Live-switch note module without reloading
      providerSel.addEventListener("change", async () => {
        updateVisibility();
        await syncNoteProvider();
      });

      if (openaiModelSel) {
        openaiModelSel.addEventListener("change", async () => {
          updateVisibility();
          await syncNoteProvider();
        });
      }

      if (noteModeSel) {
        noteModeSel.addEventListener("change", async () => {
          await syncNoteProvider();
        });
      }
    })();
  </script>

  <!-- Note usage + cost UI (safe: does NOT touch timer/status DOM) -->
  <script>
    (function () {
      window.__app = window.__app || {};

      const costEl = () => document.getElementById("noteUsageCost");
      const nfInt = new Intl.NumberFormat(undefined, { maximumFractionDigits: 0 });
      // ---- Step 4: Pricing tables + cost calculation (start with OpenAI Standard pricing) ----
      // Prices are USD per 1M tokens (Standard, non-cached input).
      // Source: OpenAI pricing docs (update here if rates change).
      const OPENAI_USD_PER_MTOK = {
        "gpt-5.1": { input: 1.25, output: 10.0 },
        "gpt-5.2": { input: 1.75, output: 14.0 },
        "chatgpt-4o-latest": { input: 5.0, output: 15.0 },
        // common alias variants (defensive; your code should prefer lowercase IDs)
        "GPT-5.1": { input: 1.25, output: 10.0 },
        "GPT-5.2": { input: 1.75, output: 14.0 },
      };
      // AWS Bedrock (Claude 4.5 only) — USD per 1M tokens
      const BEDROCK_CLAUDE45_USD_PER_MTOK = {
        "haiku-4-5":  { input: 1.0, output: 5.0 },
        "sonnet-4-5": { input: 3.0, output: 15.0 },
        "opus-4-5":   { input: 5.0, output: 25.0 },
      };
      // Mistral API (USD per 1M tokens)
      // Source: Mistral pricing announcement (Sept 17, 2024) — Mistral Large: $2/M input, $6/M output.
      const MISTRAL_USD_PER_MTOK = {
        "mistral-large-latest": { input: 0.5, output: 1.5 },
      };
      // Gemini API (AI Studio): Gemini 3 Pro Preview (USD per 1M tokens)
     // Tiering is based on prompt size (<=200K vs >200K input tokens).
      const GEMINI_3_PRO_API_USD_PER_MTOK = {
        thresholdInputTokens: 200_000,
        short: { input: 2.0, output: 12.0 }, // <= 200K input tokens
        long:  { input: 4.0, output: 18.0 }, // > 200K input tokens
      };
      // Vertex AI: Gemini 2.5 Pro (USD per 1M tokens)
      // Source: Vertex AI Generative AI pricing page (Gemini 2.5 Pro row).
      const GEMINI_25_PRO_VERTEX_USD_PER_MTOK = {
        thresholdInputTokens: 200_000,
        short: { input: 1.25, output: 10.0 }, // <= 200K input tokens
        long:  { input: 2.5,  output: 15.0 }, // > 200K input tokens
      };

      function getSelectedBedrockModelKey() {
        // Prefer UI dropdown (truth), fallback to sessionStorage
        const sel = document.getElementById("bedrockModel");
        const v = (sel && sel.value) || sessionStorage.getItem("bedrock_model") || null;
        return v ? String(v).trim() : null;
      }

      function estimateUsdFromRates({ rates, inputTokens, outputTokens }) {
        const inTok = Number(inputTokens);
        const outTok = Number(outputTokens);
        if (!Number.isFinite(inTok) || !Number.isFinite(outTok)) return null;
        const inputUsd = (inTok / 1_000_000) * rates.input;
        const outputUsd = (outTok / 1_000_000) * rates.output;
        return inputUsd + outputUsd;
      }

      function estimateUsd(payload) {
        if (!payload || typeof payload !== "object") return null;
        if (payload.estimatedUsd != null) return payload.estimatedUsd;
        if (payload.inputTokens == null || payload.outputTokens == null) return null;

        const pk = (payload.providerKey || "").toString().trim().toLowerCase();

        // OpenAI (existing): based on modelId
        if (pk.startsWith("gpt") || pk === "openai" || pk === "gpt4") {
          const modelId = payload.modelId;
          const rates = modelId ? OPENAI_USD_PER_MTOK[modelId] : null;
          if (!rates) return null;
          return estimateUsdFromRates({
            rates,
            inputTokens: payload.inputTokens,
            outputTokens: payload.outputTokens,
          });
        }
        // Mistral (direct API): based on modelId (default matches MistralTXT.js hardcode)
        if (pk === "mistral" || pk.includes("mistral")) {
          const modelId = (payload.modelId || "mistral-large-latest").toString().trim();
          const rates =
            MISTRAL_USD_PER_MTOK[modelId] ||
            (modelId.startsWith("mistral-large") ? MISTRAL_USD_PER_MTOK["mistral-large-latest"] : null);
          if (!rates) return null;
          return estimateUsdFromRates({
            rates,
            inputTokens: payload.inputTokens,
            outputTokens: payload.outputTokens,
          });
        }

        // AWS Bedrock (Claude 4.5): based on current Bedrock dropdown selection
        if (pk === "aws-bedrock" || pk.includes("bedrock")) {
          const modelKeyRaw = getSelectedBedrockModelKey();
          const modelKey = modelKeyRaw ? String(modelKeyRaw).trim() : null;
          const rates = modelKey ? BEDROCK_CLAUDE45_USD_PER_MTOK[modelKey] : null;
          if (!rates) return null;
          return estimateUsdFromRates({
            rates,
            inputTokens: payload.inputTokens,
            outputTokens: payload.outputTokens,
          });
       }
        // Gemini API (AI Studio): Gemini 3 Pro Preview
        // Output price includes thinking/reasoning tokens; tool-use prompt tokens add to input.
        if (pk === "gemini3" || (pk.includes("gemini3") && !pk.includes("vertex"))) {
          const promptTokens = Number(payload.inputTokens);
          const outTokens = Number(payload.outputTokens);
          if (!Number.isFinite(promptTokens) || !Number.isFinite(outTokens)) return null;

          const g = payload.meta && payload.meta.gemini ? payload.meta.gemini : null;
          const toolUsePrompt =
            g && typeof g.toolUsePromptTokenCount === "number" ? g.toolUsePromptTokenCount : 0;
          const thoughts =
            g && typeof g.thoughtsTokenCount === "number" ? g.thoughtsTokenCount : 0;

          const billableInput = promptTokens + toolUsePrompt;
          const billableOutput = outTokens + thoughts;

          const tier =
            promptTokens > GEMINI_3_PRO_API_USD_PER_MTOK.thresholdInputTokens ? "long" : "short";
          const rates = GEMINI_3_PRO_API_USD_PER_MTOK[tier];

          return estimateUsdFromRates({ rates, inputTokens: billableInput, outputTokens: billableOutput });
        }
        // Vertex Gemini 2.5 Pro
        if (pk.includes("vertex") || pk.includes("gemini3-vertex")) {
          const promptTokens = Number(payload.inputTokens);
          const outTokens = Number(payload.outputTokens);
          if (!Number.isFinite(promptTokens) || !Number.isFinite(outTokens)) return null;

          // Optional billing adjustments if backend provides usageMetadata counts
          const v = payload.meta && payload.meta.vertex ? payload.meta.vertex : null;
          const toolUsePrompt = v && typeof v.toolUsePromptTokenCount === "number" ? v.toolUsePromptTokenCount : 0;
          const thoughts = v && typeof v.thoughtsTokenCount === "number" ? v.thoughtsTokenCount : 0;

          const billableInput = promptTokens + toolUsePrompt;
          const billableOutput = outTokens + thoughts; // output includes reasoning on Vertex

          const tier = promptTokens > GEMINI_25_PRO_VERTEX_USD_PER_MTOK.thresholdInputTokens ? "long" : "short";
          const rates = GEMINI_25_PRO_VERTEX_USD_PER_MTOK[tier];
          return estimateUsdFromRates({ rates, inputTokens: billableInput, outputTokens: billableOutput });
        }

        return null;
        

        
      }


      function toFiniteInt(v) {
        if (typeof v === "number" && Number.isFinite(v)) return Math.trunc(v);
        if (typeof v === "string" && v.trim() !== "") {
          const n = Number(v);
          if (Number.isFinite(n)) return Math.trunc(n);
        }
        return null;
      }
      function fmtTokens(n) {
        return (typeof n === "number" && Number.isFinite(n)) ? nfInt.format(n) : "—";
      }
      function fmtUsd(n) {
        if (!(typeof n === "number" && Number.isFinite(n))) return "—";
        const abs = Math.abs(n);
        const digits = abs > 1 ? 2 : abs > 0.1 ? 3 : 6;
        return `$${n.toFixed(digits)}`;
      }

      // Step 1: normalize usage from multiple providers into one shape
      window.__app.normalizeNoteUsage = function ({ providerKey = null, modelId = null, usage = null, meta = null } = {}) {
        let inputTokens = null;
        let outputTokens = null;
        let totalTokens = null;
        const outMeta = (meta && typeof meta === "object") ? { ...meta } : {};

        if (usage && typeof usage === "object") {
          // OpenAI Responses API
          if ("input_tokens" in usage || "output_tokens" in usage) {
            inputTokens = toFiniteInt(usage.input_tokens);
            outputTokens = toFiniteInt(usage.output_tokens);
            totalTokens = toFiniteInt(usage.total_tokens);
            const rTok = toFiniteInt(usage.output_tokens_details && usage.output_tokens_details.reasoning_tokens);
            if (rTok != null) outMeta.reasoningTokens = rTok;
          }
          // Mistral (OpenAI-compatible)
          if (inputTokens == null && ("prompt_tokens" in usage || "completion_tokens" in usage)) {
            inputTokens = toFiniteInt(usage.prompt_tokens);
            outputTokens = toFiniteInt(usage.completion_tokens);
            totalTokens = toFiniteInt(usage.total_tokens);
          }
          // Gemini API usageMetadata (AI Studio)
          if (inputTokens == null && ("promptTokenCount" in usage || "candidatesTokenCount" in usage)) {
            inputTokens = toFiniteInt(usage.promptTokenCount);
            outputTokens = toFiniteInt(usage.candidatesTokenCount);
            totalTokens = toFiniteInt(usage.totalTokenCount);
            outMeta.gemini = {
              thoughtsTokenCount: toFiniteInt(usage.thoughtsTokenCount),
              toolUsePromptTokenCount: toFiniteInt(usage.toolUsePromptTokenCount),
              cachedContentTokenCount: toFiniteInt(usage.cachedContentTokenCount),
            };
          }
          // Vertex / custom backend style
          if (inputTokens == null && ("promptTokens" in usage || "outputTokens" in usage)) {
            inputTokens = toFiniteInt(usage.promptTokens);
            outputTokens = toFiniteInt(usage.outputTokens);
            totalTokens = toFiniteInt(usage.totalTokens);
            if (usage.raw && typeof usage.raw === "object") outMeta.vertex = { ...usage.raw };
          }
          // Bedrock proxy style
          if (inputTokens == null && ("inputTokens" in usage || "outputTokens" in usage)) {
            inputTokens = toFiniteInt(usage.inputTokens);
            outputTokens = toFiniteInt(usage.outputTokens);
          }
        }

        if (totalTokens == null && inputTokens != null && outputTokens != null) totalTokens = inputTokens + outputTokens;

        return {
          providerKey: providerKey ? String(providerKey) : (sessionStorage.getItem("note_provider") || null),
          modelId: modelId ? String(modelId) : null,
          inputTokens,
          outputTokens,
          totalTokens,
          estimatedUsd: null, // pricing comes later
          meta: outMeta,
        };
      };

      // Step 2: render into a SEPARATE element (not inside #noteTimer)
      window.__app.clearNoteUsageAndCost = function () {
        const el = costEl();
        if (el) el.textContent = "";
      };

      window.__app.setNoteUsageAndCost = function (payloadOrArgs) {
        let payload = payloadOrArgs;

        // allow passing {providerKey, modelId, usage, meta}
        if (payload && typeof payload === "object" && ("usage" in payload) && !("inputTokens" in payload)) {
          payload = window.__app.normalizeNoteUsage(payload);
        }

        const el = costEl();
        if (!el || !payload || typeof payload !== "object") return;
        // Auto-fill estimatedUsd if we can (OpenAI models for now)
        try {
          const usd = estimateUsd(payload);
          if (usd != null) payload.estimatedUsd = usd;
          // Optional debug: sessionStorage.setItem("debug_note_cost","1")
          if (sessionStorage.getItem("debug_note_cost") === "1") {
            console.log("[note cost estimate]", {
              providerKey: payload.providerKey,
              modelId: payload.modelId,
              inputTokens: payload.inputTokens,
              outputTokens: payload.outputTokens,
              estimatedUsd: payload.estimatedUsd,
            });
          }
        } catch (_) {}
        // --- Display: show billable tokens consistently across providers ---
        // Default: billable == raw (most providers)
        let billableInputTokens = payload.inputTokens;
        let billableOutputTokens = payload.outputTokens;
        const notes = [];

        try {
          const pk = (payload.providerKey || "").toString().trim().toLowerCase();

          // OpenAI Responses API: reasoning_tokens is a breakdown of output (do NOT add it again)
          // normalizeNoteUsage stores it as meta.reasoningTokens when available.
          const rTok =
            payload.meta && typeof payload.meta.reasoningTokens === "number"
              ? payload.meta.reasoningTokens
              : null;
          if (rTok && Number.isFinite(rTok) && rTok > 0) {
            notes.push(`${fmtTokens(rTok)} reasoning`);
          }

          // Gemini API (AI Studio): tool-use prompt counts toward input; thoughts count toward billed output
          if (pk === "gemini3" || (pk.includes("gemini3") && !pk.includes("vertex"))) {
            const g = payload.meta && payload.meta.gemini ? payload.meta.gemini : null;
            const toolUsePrompt =
              g && typeof g.toolUsePromptTokenCount === "number" ? g.toolUsePromptTokenCount : 0;
            const thoughts =
              g && typeof g.thoughtsTokenCount === "number" ? g.thoughtsTokenCount : 0;
            if (Number.isFinite(toolUsePrompt) && toolUsePrompt > 0) {
              billableInputTokens = Number(billableInputTokens ?? 0) + toolUsePrompt;
              notes.push(`${fmtTokens(toolUsePrompt)} tool-use prompt`);
            }
            if (Number.isFinite(thoughts) && thoughts > 0) {
              billableOutputTokens = Number(billableOutputTokens ?? 0) + thoughts;
              notes.push(`${fmtTokens(thoughts)} thinking`);
            }
          }

          // Vertex Gemini: same billing rule as you’re using in estimateUsd()
          if (pk.includes("vertex") || pk.includes("gemini3-vertex")) {
            const v = payload.meta && payload.meta.vertex ? payload.meta.vertex : null;
            const toolUsePrompt =
              v && typeof v.toolUsePromptTokenCount === "number" ? v.toolUsePromptTokenCount : 0;
            const thoughts =
              v && typeof v.thoughtsTokenCount === "number" ? v.thoughtsTokenCount : 0;
            if (Number.isFinite(toolUsePrompt) && toolUsePrompt > 0) {
              billableInputTokens = Number(billableInputTokens ?? 0) + toolUsePrompt;
              notes.push(`${fmtTokens(toolUsePrompt)} tool-use prompt`);
            }
            if (Number.isFinite(thoughts) && thoughts > 0) {
              billableOutputTokens = Number(billableOutputTokens ?? 0) + thoughts;
              notes.push(`${fmtTokens(thoughts)} thinking`);
            }
          }
        } catch (_) {}

        const noteSuffix = notes.length ? ` (${notes.join(", ")})` : "";

        const parts = [
          `Billable input: ${fmtTokens(billableInputTokens)}`,
          `Billable output: ${fmtTokens(billableOutputTokens)}${noteSuffix}`,
          `Est cost: ${payload.estimatedUsd == null ? "—" : fmtUsd(payload.estimatedUsd)}`
        ];
        el.textContent = parts.join("  ·  ");
      };

      // Clear stale token/cost text as soon as a new generation starts or provider changes.
      // Use capture=true so this runs before other click handlers.
      function wireAutoClear() {
        const clear = () => {
          try { window.__app.clearNoteUsageAndCost(); } catch (_) {}
        };

        const genBtn = document.getElementById("generateNoteButton");
        if (genBtn) {
         // Clear on pointerdown for immediate UX feedback, and on click as a fallback.
          genBtn.addEventListener("pointerdown", clear, true);
          genBtn.addEventListener("click", clear, true);
        }

        // Optional: clear when switching note provider/model
        const noteProviderSel = document.getElementById("noteProvider");
        if (noteProviderSel) noteProviderSel.addEventListener("change", clear, true);

        const bedrockModelSel = document.getElementById("bedrockModel");
        if (bedrockModelSel) bedrockModelSel.addEventListener("change", clear, true);
      }

      // Ensure elements exist before wiring (script might be in <head> depending on your file)
      if (document.readyState === "loading") {
        document.addEventListener("DOMContentLoaded", wireAutoClear, { once: true });
      } else {
        wireAutoClear();
      }

      // Clear on each new note generation (capture=true so we clear before other handlers)
      const genBtn = document.getElementById("generateNoteButton");
      if (genBtn) {
        genBtn.addEventListener("click", () => window.__app.clearNoteUsageAndCost(), true);
      }
    })();
  </script>

  <!-- Ensure main boot script runs after provider wiring -->
  <script type="module" src="./js/main.js"></script>

  <!-- Guide Overlay (outside the grid container) -->
  <div id="guideView">
    <button id="guideClose" type="button" aria-label="Close">×</button>
    <h3 id="guideHeading">Guide & Instructions</h3>
    <p id="guideText"></p>
  </div>

  <!-- Costs & Billing Links Overlay (opens from the two header links) -->
  <div id="billingLinksView" aria-hidden="true">
    <div class="header-row">
      <h3 id="billingLinksHeading">Costs & Billing Links</h3>
      <button id="billingLinksClose" type="button" aria-label="Close">×</button>
    </div>
    <div id="billingLinksBody">
      <!-- populated by JS -->
    </div>
  </div>

  <!-- Inline script to toggle the guide overlay -->
  <script>
    document.addEventListener("DOMContentLoaded", function () {
      const btnGuide = document.getElementById("btnGuide");
      const guideView = document.getElementById("guideView");
      const guideClose = document.getElementById("guideClose");

      if (guideClose) {
        guideClose.addEventListener("click", function () {
          guideView.classList.remove("active");
        });
      }
      if (btnGuide && guideView) {
        btnGuide.addEventListener("click", function () {
          guideView.classList.toggle("active");
        });
      }

      // Medical calculator picker (open selected HTML in new tab)
      const calcSelect = document.getElementById("medicalCalcSelect");
      const calcOpenBtn = document.getElementById("medicalCalcOpenBtn");
      function syncCalcOpenState() {
        if (!calcSelect || !calcOpenBtn) return;
        calcOpenBtn.disabled = !calcSelect.value;
      }
      if (calcSelect && calcOpenBtn) {
        syncCalcOpenState();
        calcSelect.addEventListener("change", syncCalcOpenState);
        calcOpenBtn.addEventListener("click", () => {
          const href = calcSelect.value;
          if (!href) return;
          const url = new URL(href, window.location.href).toString();
          window.open(url, "_blank", "noopener,noreferrer");
        });
      }
      // Costs/Billing links overlay (opened from the two header links)
      const usageLink = document.getElementById("openaiUsageLink");
      const walletLink = document.getElementById("openaiWalletLink");
      const billingView = document.getElementById("billingLinksView");
      const billingBody = document.getElementById("billingLinksBody");
      const billingHeading = document.getElementById("billingLinksHeading");
      const billingClose = document.getElementById("billingLinksClose");

      const providerLinks = [
        { name: "OpenAI",
          usage: "https://platform.openai.com/usage",
          billing: "https://platform.openai.com/settings/organization/billing/overview" },
         { name: "AWS Bedrock",
          usage: "https://console.aws.amazon.com/costmanagement/home?region=us-east-1#/cost-explorer",
          billing: "https://console.aws.amazon.com/costmanagement/home?region=us-east-1#/home" },
        { name: "Mistral",
          usage: "https://admin.mistral.ai/organization/usage",
          billing: "https://admin.mistral.ai/organization/billing" },
        { name: "Deepgram",
          usage: "https://console.deepgram.com/project/f9ec9a40-fad9-4177-9c43-b3158db65247/usage/overview",
          billing: "https://console.deepgram.com/" },
        { name: "Soniox",
          usage: "https://console.soniox.com/org/69ace8f7-b612-43df-80f3-1332b27475d4/projects/5c561548-5248-4cad-acd7-fc6af7b93c60/usage/cost/",
          billing: "https://console.soniox.com/" },
        { name: "Google AI Studio",
          usage: "https://aistudio.google.com/usage?timeRange=last-28-days",
          billing: "https://aistudio.google.com/usage?tab=billing" },
        { name: "Google Vertex / Cloud",
          usage: "https://console.cloud.google.com/billing",
          billing: "https://console.cloud.google.com/billing/credits" },
      ];

      function renderProviderLinksTable() {
        if (!billingBody) return;
        const usageHeader = (usageLink && usageLink.textContent || "Usage").trim();
        const billingHeader = (walletLink && walletLink.textContent || "Billing").trim();
        if (billingHeading) billingHeading.textContent = `${usageHeader} / ${billingHeader}`;

        const rows = providerLinks.map(p => {
          const u = p.usage ? `<a href="${p.usage}" target="_blank" rel="noopener noreferrer">Open</a>` : "—";
          const b = p.billing ? `<a href="${p.billing}" target="_blank" rel="noopener noreferrer">Open</a>` : "—";
          return `<tr><td>${p.name}</td><td>${u}</td><td>${b}</td></tr>`;
        }).join("");

        billingBody.innerHTML = `
          <table id="billingLinksTable">
            <thead>
              <tr>
                <th style="width: 34%;">Provider</th>
                <th style="width: 33%;">${usageHeader}</th>
                <th style="width: 33%;">${billingHeader}</th>
              </tr>
            </thead>
            <tbody>${rows}</tbody>
          </table>
        `;
      }

      function openBillingLinksOverlay() {
        if (!billingView) return;
        renderProviderLinksTable();
        billingView.classList.add("active");
        billingView.setAttribute("aria-hidden", "false");
      }
      function closeBillingLinksOverlay() {
        if (!billingView) return;
        billingView.classList.remove("active");
        billingView.setAttribute("aria-hidden", "true");
      }

      if (usageLink) usageLink.addEventListener("click", e => { e.preventDefault(); openBillingLinksOverlay(); });
      if (walletLink) walletLink.addEventListener("click", e => { e.preventDefault(); openBillingLinksOverlay(); });
      if (billingClose) billingClose.addEventListener("click", closeBillingLinksOverlay);

      document.addEventListener("keydown", function (e) {
        if (e.key === "Escape" && billingView && billingView.classList.contains("active")) {
          closeBillingLinksOverlay();
        }
      });

      // Copy generated note to clipboard
      const copyBtn = document.getElementById("copyNoteButton");
      const noteEl = document.getElementById("generatedNote");
      if (copyBtn && noteEl) {
        const originalLabel = copyBtn.textContent;
        copyBtn.addEventListener("click", async () => {
          const text = (noteEl.value || "").trim();
          if (!text) return;
          try {
            await navigator.clipboard.writeText(text);
            copyBtn.textContent = "Copied";
            setTimeout(() => { copyBtn.textContent = originalLabel; }, 1200);
          } catch (err) {
            // Fallback for older browsers / blocked clipboard permissions
            try {
              noteEl.focus();
              noteEl.select();
              document.execCommand("copy");
              copyBtn.textContent = "Copied";
              setTimeout(() => { copyBtn.textContent = originalLabel; }, 1200);
            } catch (_) {
              console.warn("Copy failed", err);
            } finally {
              try { window.getSelection()?.removeAllRanges?.(); } catch {}
            }
          }
        });
      }
    });
  </script>



  <!-- Enforce grid container height on load, resize, and after a short delay -->
  <script>
    function setGridHeight() {
      const grid = document.querySelector(".grid-container");
      if (grid) {
        let height = window.visualViewport ? window.visualViewport.height : window.innerHeight;
        grid.style.height = height + "px";
      }
    }
    window.addEventListener("load", function () {
      setGridHeight();
      let interval = setInterval(setGridHeight, 200);
      setTimeout(() => clearInterval(interval), 2000);
    });
    window.addEventListener("resize", setGridHeight);
  </script>

  <script>
    // Simple toggle for ad sidebars: set ADS_ENABLED to true/false
    // - true  = show left/right columns (current behavior)
    // - false = hide sidebars and use full-width layout
    const ADS_ENABLED = false; // change this to false to start in "wide screen" mode

    document.addEventListener('DOMContentLoaded', () => {
      const grid = document.querySelector('.grid-container');
      if (!grid) return;
      if (!ADS_ENABLED) {
        grid.classList.add('ads-disabled');
      } else {
        grid.classList.remove('ads-disabled');
      }
    });

    // Optional: manual runtime toggle from console or other code:
    //   setAdsEnabled(false) → hide sidebars
    //   setAdsEnabled(true)  → show sidebars
    window.setAdsEnabled = function(enabled) {
      const grid = document.querySelector('.grid-container');
      if (!grid) return;
      if (enabled) {
        grid.classList.remove('ads-disabled');
      } else {
        grid.classList.add('ads-disabled');
      }
    };
  </script>

<script>
  // 1) Generate or retrieve a per-browser anonymous visitorId
  let visitorId = localStorage.getItem('visitorId');
  if (!visitorId) {
    visitorId = (crypto.randomUUID && crypto.randomUUID()) ||
                Math.random().toString(36).substr(2, 9);
    localStorage.setItem('visitorId', visitorId);
  }
  function getTranscribeProviderSnapshot() {
    return {
      transcribeProvider:
        document.getElementById('transcribeProvider')?.value ||
        sessionStorage.getItem('transcribe_provider') ||
        '',
      sonioxSpeakerLabels:
        document.getElementById('sonioxSpeakerLabels')?.value ||
        sessionStorage.getItem('soniox_speaker_labels') ||
        '',
      sonioxRegion:
        document.getElementById('sonioxRegion')?.value ||
        sessionStorage.getItem('soniox_region') ||
        '',
    };
  }

  function getNoteProviderSnapshot() {
    const uiProvider =
      document.getElementById('noteProvider')?.value || '';
    const effective =
      sessionStorage.getItem('note_provider') || '';

    // Bedrock stores the chosen model separately (bedrock_model).
    // Keep sessionStorage.note_provider untouched for app logic, but log model for analytics.
    const bedrockModel =
      document.getElementById('bedrockModel')?.value ||
      sessionStorage.getItem('bedrock_model') ||
      '';

    // (Optional) Vertex also stores model separately (vertex_model)
    const vertexModel =
      document.getElementById('vertexModel')?.value ||
      sessionStorage.getItem('vertex_model') ||
      '';

    // Column I already stores provider; Column J should store "model" (or effective id)
    const effectiveForLog =
      (effective === 'aws-bedrock' && bedrockModel) ? bedrockModel :
      (effective === 'gemini3-vertex' && vertexModel) ? vertexModel :
      effective;

    return {
      noteProviderUi: uiProvider,
      noteProviderEffective: effectiveForLog,
    };
  }


  // 2) Helper to log an event to your Apps Script
  function logEvent(params = {}) {
    const baseUrl = 'https://script.google.com/macros/s/AKfycbz3bpMrPJXAtyNCIoj6h2v3GewLRF90dQeEpC81F_m9rNClLVMUuQEGVO8yinlhssc/exec';
    const qs = new URLSearchParams({
      visitorId,
      page: window.location.pathname,
      userAgent: navigator.userAgent,
      referrer: document.referrer,
      ...params
    }).toString();
    fetch(`${baseUrl}?${qs}`, { mode: 'no-cors', keepalive: true });
  }

  // 3) Log pageview after DOM is ready + log clicks with provider context
  document.addEventListener('DOMContentLoaded', () => {
    // Optional: keep pageview lean (no provider fields)
    logEvent({ action: 'pageview' });

    document.addEventListener('click', (e) => {
      const btn = e.target && e.target.closest ? e.target.closest('button') : null;
      const id = btn && btn.id;
      if (id === 'stopButton') {
        // Recording event: only include transcription provider context
        logEvent({ action: 'stopRecording', ...getTranscribeProviderSnapshot() })
      } else if (id === 'generateNoteButton') {
        // Note event: only include note provider context
        logEvent({ action: 'noteGeneration', ...getNoteProviderSnapshot() });
      } else if (id === 'medicalCalcOpenBtn') {
        // Clinical tool open event: encode selection into the existing "action" column
        const sel = document.getElementById('medicalCalcSelect');
        const href = sel?.value || '';
        const label =
          (sel?.selectedOptions?.[0]?.textContent || '').trim();
        if (href) {
          // Example action:
          // openClinicalTool|./growth_charts_no_upload.html|Vektskurver WHO barn 0-19 år
          logEvent({ action: `openClinicalTool|${href}|${label}` });
        }
      }
    }, true);
  // Clear button logic for supplementary field
  const clearSupplementaryButton = document.getElementById('clearSupplementaryButton');
  if (clearSupplementaryButton) {
    clearSupplementaryButton.addEventListener('click', () => {
      const supEl = document.getElementById('supplementaryInfo');
      if (supEl) {
        supEl.value = '';
        if (typeof autoResize === 'function') {
          try { autoResize(supEl); } catch {}
        }
      }
    });
  }
  // Clear button logic for transcription field
  const clearTranscriptionButton = document.getElementById('clearTranscriptionButton');
  if (clearTranscriptionButton) {
    clearTranscriptionButton.addEventListener('click', () => {
      const trEl = document.getElementById('transcription');
      if (trEl) {
        trEl.value = '';
        if (typeof autoResize === 'function') {
          try { autoResize(trEl); } catch {}
        }
      }
    });
  }
  });
</script>

  
  <!-- Centralized prompt slot control (bound to transcribe.html) -->
  <script type="module">
    import { PromptManager } from "./js/promptManager.js";

    const promptSlotSelect = document.getElementById("promptSlot");
    const customPromptTextarea = document.getElementById("customPrompt");


    // New: prompt profile UI elements
    const promptProfileValue = document.getElementById("promptProfileValue");
    const promptExportBtn = document.getElementById("promptExportBtn");
    const promptImportBtn = document.getElementById("promptImportBtn");
    const promptImportFile = document.getElementById("promptImportFile");

    // We'll re-use the same loader that the slot UI uses (defined below).
    // We create a safe wrapper here so we can call it after profile changes.
    function reloadCurrentPromptSlot() {
      if (!promptSlotSelect || !customPromptTextarea) return;
      // PromptManager.loadPrompt updates #customPrompt itself in your current codebase.
      PromptManager.loadPrompt(promptSlotSelect.value);
    }


    function renderPromptProfileLabel() {
      if (!promptProfileValue) return;
      const pid = (typeof PromptManager.getPromptProfileId === "function")
        ? PromptManager.getPromptProfileId()
        : ((localStorage.getItem("prompt_profile_id") || "").trim());
      promptProfileValue.textContent = pid ? pid : "(not set)";
    }

    function ensurePromptProfileId({ allowChange = false } = {}) {
      const existing = (typeof PromptManager.getPromptProfileId === "function")
        ? PromptManager.getPromptProfileId()
        : ((localStorage.getItem("prompt_profile_id") || "").trim());
      if (existing && !allowChange) return existing;

      const currentHint = existing ? `Current: ${existing}\n\n` : "";
      const entered = (window.prompt(
        `${currentHint}Set a Prompt profile ID (e.g. "David", "David1"):\n\n(Stored on this device)`,
        existing || ""
      ) || "").trim();
      if (!entered) return "";

      if (typeof PromptManager.setPromptProfileId === "function") {
        PromptManager.setPromptProfileId(entered);
      } else {
        try { localStorage.setItem("prompt_profile_id", entered); } catch {}
      }
      renderPromptProfileLabel();
      // Important: switching profiles changes the namespace; reload the visible slot.
      reloadCurrentPromptSlot();
      return entered;
    }

    // Initial render
    renderPromptProfileLabel();

    if (promptSlotSelect && customPromptTextarea) {
      let isLoadingPrompt = false;

      function loadCurrentSlot() {
        isLoadingPrompt = true;
        PromptManager.loadPrompt(promptSlotSelect.value);
        isLoadingPrompt = false;
      }

      // Initial load
      loadCurrentSlot();

      // Save on user input
      customPromptTextarea.addEventListener("input", () => {
        if (isLoadingPrompt) return;
        PromptManager.savePrompt(promptSlotSelect.value, customPromptTextarea.value);
        customPromptTextarea.style.height = "auto";
        customPromptTextarea.style.height = customPromptTextarea.scrollHeight + "px";
      });

      // Load new prompt on slot change
      promptSlotSelect.addEventListener("change", loadCurrentSlot);
    }

    // Optional: allow clicking the profile value to change it quickly
    if (promptProfileValue) {
      promptProfileValue.style.cursor = "pointer";
      promptProfileValue.title = "Click to set/change prompt profile";
      promptProfileValue.addEventListener("click", () => {
        ensurePromptProfileId({ allowChange: true });
      });
    }


    // Wire Import/Export buttons (safe now; real logic added in later steps)
    if (promptExportBtn) {
      promptExportBtn.addEventListener("click", () => {
        const pid = ensurePromptProfileId();
        if (!pid) return;
        // Will be implemented in later steps
        if (typeof PromptManager.exportPromptsToFile === "function") {
          PromptManager.exportPromptsToFile();
        } else {
          // No-op for now; keeps UX clear during incremental implementation
          console.warn("Export not implemented yet (PromptManager.exportPromptsToFile missing).");
        }
      });
    }

    if (promptImportBtn && promptImportFile) {
      promptImportBtn.addEventListener("click", () => {
        const pid = ensurePromptProfileId();
        if (!pid) return;
        promptImportFile.value = "";
        promptImportFile.click();
      });

      promptImportFile.addEventListener("change", async () => {
        const file = promptImportFile.files && promptImportFile.files[0];
        if (!file) return;
        // Will be implemented in later steps
        if (typeof PromptManager.importPromptsFromFile === "function") {
          await PromptManager.importPromptsFromFile(file);
          // After import, refresh visible slot
          reloadCurrentPromptSlot();
        } else {
          console.warn("Import not implemented yet (PromptManager.importPromptsFromFile missing).");
        }
      });
    }
  </script>

<script>
  googletag.cmd.push(function() {
    // reuse the slots you already defined above
    const refreshSlots = [
      window.slotTopLeft,
      window.slotTopRight,
      window.slotBottomLeft,
      window.slotBottomRight
    ];

    // simple cooldown
    let lastRefresh = Date.now();
    const MIN_REFRESH_INTERVAL = 5 * 60 * 1000; // 5 min cooldown

    function refreshAds() {
      const now = Date.now();
      if (now - lastRefresh < MIN_REFRESH_INTERVAL) return;
      // refresh without changing the correlator
      googletag.pubads().refresh(refreshSlots, { changeCorrelator: false });
      lastRefresh = now;
      console.log('Ads refreshed at', new Date().toLocaleTimeString());
    }

    // hook into your existing buttons
    ['startButton','stopButton','generateNoteButton']
      .forEach(id => {
        const btn = document.getElementById(id);
        if (btn) btn.addEventListener('click', refreshAds);
      });
  });
</script>
  <!-- Centralized Recording Timer
       Rules:
       Start  -> reset + run
       Pause  -> freeze
       Resume -> continue (no speech required)
       Stop   -> freeze (no reset). Only Start can reset+run again.
  -->
  <script>
    (function () {
      // Prevent double-init (in case of soft reloads / hot switches)
      if (window.__recordTimerControllerInitialized) return;
      window.__recordTimerControllerInitialized = true;

      const PREFIX = "Recording Timer:";

      const timerEl = document.getElementById("recordTimer");
      const startBtn = document.getElementById("startButton");
      const stopBtn = document.getElementById("stopButton");
      const pauseBtn = document.getElementById("pauseResumeButton");

      if (!timerEl || !startBtn || !stopBtn || !pauseBtn) return;

      let elapsedMs = 0;          // accumulated frozen time
      let running = false;        // true while ticking
      let startedAtMs = 0;        // Date.now() when last (re)started
      let intervalId = null;
      let blockedUntilStart = true; // blocks resume after Stop (and before first Start)
      let pendingStart = false;      // Start clicked, waiting for Stop to be enabled
      let pendingStartTimeoutId = null;
      let pendingStartPollId = null;

      function formatTime(ms) {
        const totalSec = Math.floor(ms / 1000);
        if (totalSec < 60) return `${totalSec} sec`;
        const m = Math.floor(totalSec / 60);
        const s = totalSec % 60;
        return s > 0 ? `${m} min ${s} sec` : `${m} min`;
      }

      function currentElapsedMs() {
        return running ? (elapsedMs + (Date.now() - startedAtMs)) : elapsedMs;
      }

      function render() {
        timerEl.textContent = `${PREFIX} ${formatTime(currentElapsedMs())}`;
      }

      function clearTick() {
        if (intervalId) {
          clearInterval(intervalId);
          intervalId = null;
        }
      }

      function startTicking() {
        clearTick();
        intervalId = setInterval(render, 1000);
      }

      function clearPendingStartTimeout() {
        if (pendingStartTimeoutId) {
          clearTimeout(pendingStartTimeoutId);
          pendingStartTimeoutId = null;
        }
      }

      function clearPendingStartPoll() {
        if (pendingStartPollId) {
          clearInterval(pendingStartPollId);
          pendingStartPollId = null;
        }
      }

      // Start clicked: reset display, then wait until STOP becomes enabled to begin ticking.
      function armStart() {
        clearPendingStartTimeout();
        clearPendingStartPoll();

        pendingStart = true;
        blockedUntilStart = true; // don't allow resume until start is confirmed

        elapsedMs = 0;
        running = false;
        clearTick();
        render();

        // Poll for the *current* stop button (survives main.js button cloning)
        pendingStartPollId = setInterval(() => {
          if (!pendingStart) return;
          const sb = document.getElementById("stopButton");
          if (sb && sb.disabled === false) {
            confirmStart();
          }
        }, 100);

        // Safety timeout: if Stop never enables, treat it as not started
        pendingStartTimeoutId = setTimeout(() => {
          if (!pendingStart) return;
          cancelStart();
        }, 60000);
      }

      function confirmStart() {
        if (!pendingStart) return;
        pendingStart = false;
        clearPendingStartTimeout();
        clearPendingStartPoll();

        blockedUntilStart = false;
        elapsedMs = 0;
        running = true;
        startedAtMs = Date.now();
        render();
        startTicking();
      }

      function cancelStart() {
        if (!pendingStart) return;
        pendingStart = false;
        clearPendingStartTimeout();
        clearPendingStartPoll();

        blockedUntilStart = true;
        running = false;
        elapsedMs = 0;
        clearTick();
        render();
      }

      function freeze() {
        if (!running) {
          render();
          return;
        }
        elapsedMs += Date.now() - startedAtMs;
        running = false;
        clearTick();
        render();
      }

      function resume() {
        if (blockedUntilStart) return;   // after Stop, only Start can restart
        if (running) return;
        if (elapsedMs <= 0) return;      // nothing to resume yet
        running = true;
        startedAtMs = Date.now();
        render();
        startTicking();
      }

      // Initial render should match existing HTML text
      render();

      // Capture-phase delegation so provider “button cloning” doesn’t break us
      document.addEventListener("click", (e) => {
        const id = e.target && e.target.id;
        if (id === "startButton") {
          armStart();
        } else if (id === "stopButton") {
          // If Start never actually succeeded, cancel the pending start cleanly
          cancelStart();
          freeze();
          blockedUntilStart = true; // stop behaves like “end session”
        } else if (id === "pauseResumeButton") {
          if (running) freeze();
          else resume();
        }
      }, true);
    })();
  </script>

<!-- Keep final elapsed time visible; show completion status to the right -->
<script>
  (function () {
    const timerEl = document.getElementById("noteTimer");
    if (!timerEl) return;
    const belowEl = document.getElementById("noteTimerStatusBelow");

    const TIMER_PREFIX = "Note Generation Timer:";
    const COMPLETED_RE = /completed/i;
    // Treat localized timer text as "timer updates" too, not status.
    const TIMER_LIKE_RE = /\b\d+\s*(sec|sek|min|mins|minute|minutes|minut|minutter)\b/i;

    let lastTimerText = "";
    let suppress = false;

    function ensureStructure(timerText, statusText) {
      suppress = true;
      try {
        timerEl.innerHTML = "";

        const valueSpan = document.createElement("span");
        valueSpan.id = "noteTimerValue";
        valueSpan.textContent = timerText || `${TIMER_PREFIX} 0 sec`;

        const statusSpan = document.createElement("span");
        statusSpan.id = "noteTimerStatus";
        statusSpan.className = "timer-status";
        statusSpan.textContent = statusText || "";

        timerEl.appendChild(valueSpan);
        timerEl.appendChild(statusSpan);
      } finally {
        // Let the DOM settle before re-enabling observer reactions
        setTimeout(() => { suppress = false; }, 0);
      }
    }

    function setBelowStatus(text) {
      if (!belowEl) return;
      belowEl.textContent = text || "";
    }

    // Initialize wrapper around any existing content
    const initialText = (timerEl.textContent || "").trim();
    if (initialText.startsWith(TIMER_PREFIX)) lastTimerText = initialText;
    ensureStructure(lastTimerText || `${TIMER_PREFIX} 0 sec`, "");
    setBelowStatus("");

    const observer = new MutationObserver(() => {
      if (suppress) return;

      // If our spans are present, we’re already structured—no action needed.
      const valueSpan = timerEl.querySelector("#noteTimerValue");
      const statusSpan = timerEl.querySelector("#noteTimerStatus");
      if (valueSpan && statusSpan) {
        const v = (valueSpan.textContent || "").trim();
        if (v.startsWith(TIMER_PREFIX)) lastTimerText = v;
        return;
      }

      // Provider scripts often replace innerText entirely; capture that.
      const raw = (timerEl.textContent || "").trim();

      if (!raw) {
        // Some providers blank the timer on errors; restore last known timer if we have one.
        ensureStructure(lastTimerText || `${TIMER_PREFIX} 0 sec`, "");
        setBelowStatus("");
        return;
      }

      
      if (COMPLETED_RE.test(raw)) {
        // Completion: freeze the last timer value and show status ONLY below the timer
        const finalTimer = lastTimerText || `${TIMER_PREFIX} 0 sec`;
        ensureStructure(finalTimer, "");      // <-- keep right-side status empty
        setBelowStatus("Completed!");         // <-- show only below
        return;                               // <-- IMPORTANT: prevent fallback from clearing it
      }

      // Timer ticking updates (including localized strings) should never become "status".
      if (raw.startsWith(TIMER_PREFIX) || TIMER_LIKE_RE.test(raw)) {
        lastTimerText = raw;
        ensureStructure(raw, "");
        setBelowStatus("");
        return;
      }

      // Any other unexpected text: keep timer frozen, but DO NOT show it as status
      // (prevents duplicate timer strings like "Notatgenereringstimer: 0 sek" appearing on the right).
      ensureStructure(lastTimerText || `${TIMER_PREFIX} 0 sec`, "");
      setBelowStatus("");
    });

    observer.observe(timerEl, { childList: true, characterData: true, subtree: true });

    // On a new run, reset display immediately (providers will start ticking as usual)
    const genBtn = document.getElementById("generateNoteButton");
    if (genBtn) {
      genBtn.addEventListener(
        "click",
        () => {
          lastTimerText = `${TIMER_PREFIX} 0 sec`;
          ensureStructure(lastTimerText, "");
          setBelowStatus("");
        },
        true // capture: run before any bubbling handlers
      );
    }
  })();
</script>
  <!-- Lock provider switching while recording is active.
       Recording is considered "active" when Stop is enabled (disabled === false). -->
  <script>
    (function () {
      function setLocked(locked) {
        const providerSel = document.getElementById("transcribeProvider");
        const spkSel = document.getElementById("sonioxSpeakerLabels");
        const regionSel = document.getElementById("sonioxRegion");
        if (providerSel) providerSel.disabled = !!locked;
        if (spkSel) spkSel.disabled = !!locked;
        if (regionSel) regionSel.disabled = !!locked;
      }

      let lastLocked = null;
      setInterval(() => {
        const stopBtn = document.getElementById("stopButton");
        const locked = !!(stopBtn && stopBtn.disabled === false);
        if (locked !== lastLocked) {
          setLocked(locked);
          lastLocked = locked;
        }
      }, 200);
    })();
  </script>
</body>
</html>






